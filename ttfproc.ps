%!

/MaxFontsPerFile 1000 def
/MaxTablesPerFonts 1000 def
/MaxNamesPerFonts 1000 def
/MaxStringBuffer 256 def
/ttfprocDebug { exec } def
/ttfprocVerbose { pop } def
/ttfprocMoreVerbose { pop } def
/aprintDebug { ttfprocDebug { aprint } ttfprocDebug } def
/aprintVerbose { ttfprocVerbose { aprint } ttfprocVerbose } def
/aprintMoreVerbose { ttfprocMoreVerbose { aprint } ttfprocMoreVerbose } def

% value object key [ vokput ] -
/vokput { 2 index put pop } bind def

% name <loadexec> obj exec
/loadexec {
	load /exec cvx
} bind def

% <dict> <key> knownget ( <val> true ) | false
% knownget has same functionality as .knownget in GS.
/knownget {
	2 copy known { get true } { pop pop false } ifelse
} bind def

% <default> <dict> <key> tinydefaultget <val>
% return value for key in dict, if found.
% return default if else.
% order of parameter is different from defaultget in akamoz-util.ps
/tinydefaultget {
	knownget { exch pop } if
} bind def

% proc <protected-exec> -
%	dictionary stack is poped, execute proc,
%	then the dictionary stack is restored.
%	exit will be trapped. if exit is executed in proc, exit is re-executed,
%	and "exited" is set to true, false otherwise.
/protected-exec {
	1 {
		/exited true def
		[ /exec cvx currentdict ] cvx end exec
		/exited false put
	} [ /repeat cvx currentdict ] cvx exec begin
	exited { exit } if
} bind def

% array proc <for-array> -
%	procspec: array num <proc> -
/for-array {
	1 dict begin
	/p exch def
	/a exch def
	0 1 a length 1 sub {
		a exch /p load protected-exec
	} for
	end
} bind def

% array proc <for-array-reverse> -
%	procspec: array num <proc> -
/for-array-reverse {
	1 dict begin
	/p exch def
	/a exch def
	a length 1 sub -1 0 {
		a exch /p load protected-exec
	} for
	end
} bind def

% - [ strbufCreate ] strbuf
/strbufCreate {
	<< /buf () /pos 0 >>
} def

% strbuf <strbufLength> int
/strbufLength {
	/pos get
} bind def

% strbuf len [ strbufRealloc ] -
/strbufRealloc {
	2 dict begin
	/len exch def
	/strbuf exch def
	strbuf /buf get length
	dup len lt {
		2 mul
		dup len lt { pop len } if
		{ (realloc to ) print dup == } pop
		string dup 0 strbuf /buf get putinterval strbuf /buf vokput
	} {
		pop
	} ifelse
	end
} bind def

% strbuf str [ strbufAppend ] -
/strbufAppend {
	1 index begin
	3 dict begin
	/str exch def
	/strbuf exch def
	/newlen pos str length add def
	strbuf newlen strbufRealloc
	buf pos str putinterval
	strbuf /pos newlen put
	end end
} bind def

% strbuf int [ strbufAppendInt ] -
/strbufAppendInt {
	1 index begin
	3 dict begin
	/n exch def
	/strbuf exch def
	/newlen pos 1 add def
	strbuf newlen strbufRealloc
	buf pos n put
	strbuf /pos newlen put
	end end
} bind def

% strbuf [ strbufGetString ] string
/strbufGetString {
	begin
	buf 0 pos getinterval
	end
} bind def

% str num <splitstring> substrtail substrhead
/splitstring {
	2 dict begin
	/n exch def
	/s exch def
 	s n s length n sub getinterval
	s 0 n getinterval
	end
} bind def

% str <charbytes> num
/charbytesUTF8 {
	0 get
	dup 16#80 lt { 1 } {
	dup 16#c2 lt { /charbytesUTF8 trap } {
	dup 16#e0 lt { 2 } {
	dup 16#f0 lt { 3 } {
	dup 16#f8 lt { 4 } {
		/charbytesUTF8 trap	% default
	} ifelse } ifelse } ifelse } ifelse } ifelse
	exch pop
} bind def

/charbytesUCS2 {
	pop 2
} bind def

/charbytesUTF16BE {
	0 get
	dup 16#d8 lt { 2 } {
	dup 16#dc lt { 4 } {
	dup 16#e0 lt { /charbytesUTF16 trap } {
		2	% default
	} ifelse } ifelse } ifelse
} bind def

/charbytesUTF32 {
	pop 4
} bind def

% num <checkUnicode> num
/checkUnicode {
	dup 16#d800 lt { } {
	dup 16#e000 lt { /checkUnicode trap } {
	dup 16#110000 lt { } {
		/checkUnicode trap % default
	} ifelse } ifelse } ifelse
} bind def

% str <decode> num

/decodeUTF8Mask [ 16#ff 16#1f 16#0f 16#07 ] def
/decodeUTF8Limit [ 0 16#80 16#800 16#10000 ] def

% str <decodeUTF8> substrtail num
/decodeUTF8 {
	2 dict begin
	/s exch def
	s charbytesUTF8
	s 1 index splitstring pop exch
	1 sub /taillen exch def
	s 0 get //decodeUTF8Mask taillen get and
	s 1 taillen getinterval
	{
		dup 16#80 lt { /decodeUTF8b trap } if
		dup 16#c0 ge { /decodeUTF8c trap } if
		16#3f and exch 6 bitshift add
	} forall
	checkUnicode
	dup //decodeUTF8Limit taillen get lt { /decodeutf8d trap } if
	end
} bind def

currentdict /decodeUTF8Mask undef
currentdict /decodeUTF8Limit undef

% num <encodeUTF8> str
/encodeUTF8 {
	1 dict begin
	/u exch def
	u 16#80 lt {
		1 string dup 0 u put
	} {
		u 16#800 lt { 2 16#c0 } {
		u 16#10000 lt { 3 16#e0 } {
		u 16#110000 lt { 4 16#f0 } {
			/encodeUTF8 trap	% default
		} ifelse } ifelse } ifelse
		/msb exch def
		dup string exch
		1 sub -6 mul /bs exch def
		dup {
			u bs bitshift 16#3f and msb or put
			/msb 16#80 def
			/bs bs 6 add def
		} for-array
	} ifelse
	end
} bind def

% str <_decodeUCS2> num
/_decodeUCS2 {
	dup 1 get exch 0 get 8 bitshift add
} bind def

% str <decodeUCS2> substrtail num
/decodeUCS2 {
	2 splitstring
	_decodeUCS2
	checkUnicode
} bind def 

% str num <_encodeUCS2> str
/_encodeUCS2 {
	1 index 0 2 index -8 bitshift put
	1 index exch 1 exch 16#ff and put
} bind def

% num <encodeUCS2> str
/encodeUCS2 {
	checkUnicode
	dup 16#10000 ge { /encodeUCS2 trap } if
	2 string exch _encodeUCS2
} bind def

% str <decodeUTF16> substrtail num
/decodeUTF16 {
	2 splitstring _decodeUCS2
	dup 16#dc00 ge 1 index 16#e000 lt and { /decodeUTF16a trap } if
	dup 16#d800 ge 1 index 16#dc00 lt and {
		exch 2 splitstring _decodeUCS2	% hi substr lo
		dup 16#dc00 lt 1 index 16#e000 ge or { /decodeUTF16b trap } if
		3 -1 roll	% substr lo hi
		16#3ff and 10 bitshift exch 16#3ff and add 16#10000 add
	} if
	checkUnicode
} bind def

% num <encodeUTF16> str
/encodeUTF16 {
	checkUnicode
	dup 16#10000 lt {
		2 string exch _encodeUCS2
	} {
		16#10000 sub
		4 string exch
		dup 16#3ff and 16#dc00 add exch
		-10 bitshift 16#d800 add
		2 index 0 2 getinterval exch _encodeUCS2 pop
		1 index 2 2 getinterval exch _encodeUCS2 pop
	} ifelse
} bind def

% str <decodeUTF32> num
/decodeUTF32 {
	4 splitstring 0 exch {
		exch 8 bitshift add
	} forall
	checkUnicode
} bind def

% num <encodeUTF32> num
/encodeUTF32 {
	checkUnicode
	4 string exch 1 index {
		3 exch sub
		2 index 16#ff and put
		-8 bitshift
	} for-array
	pop
} bind def

% arrayofstr <concatallstring> str
/concatallstring {
	dup 0 exch { length add } forall
	string exch
	0 exch {
		dup length exch
		3 index exch 3 index exch putinterval
		add
	} forall pop
} bind def

% str dec-encproc <convertstring> str'
%	dec-encproc: str <dec-encproc> substrtail strchar
/convertstring {
	1 dict begin
	/decenc exch def
	[ exch {
		dup length 0 eq { exit } if
		/decenc load protected-exec exch
	} loop pop ]
	concatallstring
	end
} bind def

% <obj> <proc> exec-forall -
/exec-forall {
	1 index type /arraytype eq {
		forall
	} {
		1 exch repeat
	} ifelse
} bind def

% file num <forward> -
/forward {
	1 index fileposition add setfileposition
} bind def
% str <str2num> num
/str2num {
	0 exch { exch 8 bitshift add } forall
} bind def

/aprint-float-digits {
	dup 0.1 mul 0.05 add floor exch % div val
	1 index 10 mul sub round	% div mod
	dup 0 lt { pop (0) } {
	dup 9 gt { pop (9) } {
		cvi 1 string cvs	% default
	} ifelse } ifelse exch
} bind def

/aprint-longval-divmod10 {
	1 dict begin
	/m 0 def
	/f true def
	[ exch {
		m 256 mul add dup 10 idiv exch
		10 mod /m exch def
		dup 0 eq f and { pop } if
		/f false def
	} forall ]
	m
	end
} bind def

% val width <aprint-float-fixed> str
/aprint-float-fixed {
	1 dict begin
	/prec exch def
	/val exch def
	/str strbufCreate def
	/s 1 string def

	% 符号
	val 0 lt {
		str (-) strbufAppend
		/val val abs def
	} if

	% 丸めておく
	/val val 10 prec neg exp 0.5 mul add def

	% 整数部と小数部に分ける
	/ipart val floor def
	/fpart val ipart sub def

	% 整数部を256進表現にする。
	/n 0 def
	{
		ipart 1 lt { exit } if
		/ipart ipart 256 div def
		/n n 8 add def
		n 5000 gt { /aprint-float-overflow trap } if
	} loop
	/ipart [ ipart n 8 idiv {
		256 mul dup floor cvi exch 1 index sub
	} repeat pop ] def

	% 下位桁から10進分解する。
	mark {
		ipart length 0 eq { exit } if
		ipart aprint-longval-divmod10 exch /ipart exch def
	} loop

	% 文字列に直す
	{
		dup mark eq { exit } if
		s cvs str exch strbufAppend
	} loop
	pop

	% 空っぽなら0を追加
	str strbufLength 0 eq { str (0) strbufAppend } if

	% 小数部
	str (.) strbufAppend
	fpart prec {
		10 mul dup floor dup cvi s cvs
		str exch strbufAppend
		sub
	} repeat pop

	str strbufGetString
	end
} bind def

% str aprint-align -
%	use W A F to formatting
/aprint-align {
	dup length	% str len
	W exch sub	% str W-len
	dup 0 le {
		pop print
	} { A /right eq {
		{ ( ) print } repeat print
	} { A /left eq {
		exch print { ( ) print } repeat
	} { A type /stringtype eq {
		1 index 0 1 getinterval (-) eq {
			(-) print { A print } repeat
			1 1 index length 1 sub getinterval print
		} {
			{ A print } repeat print
		} ifelse
	} {
		/aprint-align trap
	} ifelse } ifelse } ifelse } ifelse
} bind def

% array <aprint> -
% anyother <aprint> -
/aprint {
	1 dict begin
	/W 0 def	% field width
	/P 6 def	% precision
	/A /right def	% align: /right, /left or string to fill
	/F /fixed def	% floating point format
	/R 10 def	% radix
	{ 1 {
		dup type /integertype eq { R 32 string cvrs aprint-align exit } if
		dup type /realtype eq { P aprint-float-fixed aprint-align exit } if
		dup type /dicttype eq { { def } forall exit } if
		dup type /stringtype eq { print exit } if
		dup type /nametype eq { dup length string cvs print exit } if
		dup type /booleantype eq {
			{ (true) } { (false) } ifelse print exit
		} if
		/aprint trap
	} repeat } exec-forall
	end
} bind def

/dstack {
	(--- ) print aprint ( ---\n) print
	pstack
	(---------\n) print flush
} bind def

% file num <bindfilebuffer> obj
/bindfilebuffer {
	[ 3 1 roll string /readstring cvx /not cvx ] cvx
} bind def

% file <ttfReadTTCHeader> file array
/ttfReadTTCHeader {
	1 dict begin
	dup 4 bindfilebuffer /b4 exch def
	dup fileposition
	b4 { /ttfc0 trap } if
	(ttcf) eq {
		% TrueType Collection
		(TrueType Collection: ) aprintDebug
		pop
		b4 { /ttfcver0 trap } if
		str2num 16#00010000 lt { /ttcfver1 trap } if
		b4 { /ttfcnumf0 trap } if
		str2num dup MaxFontsPerFile gt { /ttfcnumf1 trap } if
		[ (numfonts=) 2 index (\n) ] aprintDebug
		array dup {
			[ (  font ) 2 index (: ) ] aprintVerbose
			b4 { /ttcfoff0 trap } if str2num
			[ (off=) 2 index (\n) ] aprintVerbose
			put
		} for-array
	} {
		% must be TrueType single font
		1 array astore
	} ifelse
	end
} bind def

% num <ttfPrintVersion> -
/ttfPrintVersion {
	[
		1 index -16 bitshift (.)
		<< /R 16 /W 4 /A (0) >> 4 index 16#ffff and
	] aprint
	pop
} bind def

% file array subfontnum <ttfReadTrueTypeHeader> ttfdict
/ttfReadTrueTypeHeader {
	3 array astore
	dup 1 get 1 index 2 get get dup type /integertype ne {
		exch pop
	} {
		% [ file array subfontnum ] offset
		1 dict begin
		/offset exch def
		aload pop
		/subfontnum exch def
		/a exch def
		/f exch def
		/ttftable 1 dict def
		/b4 f 4 bindfilebuffer def
		/b2 f 2 bindfilebuffer def
		f offset setfileposition

		[ (TrueType Offset Table: subfont=) subfontnum ] aprintDebug
		[ ( off=) offset ] aprintDebug
		b4 { /ttfhver0 trap } if
		str2num { dup ( version=) print ttfPrintVersion } ttfprocDebug
		16#00010000 ne { /ttfhver1 trap } if
		b2 { /ttfnumtbl0 trap } if
		str2num [ ( numtables=) 2 index (\n) ] aprintDebug
		dup MaxTablesPerFonts gt { /ttfnumtbl1 trap } if
		f 6 forward
		{	% << name [ off len ] ... >>
			ttftable
			b4 { /ttfhtblid trap } if
			cvn [ (  id=) 2 index ] aprintVerbose
			f 4 forward
			[
				b4 { /ttfhtbloff trap } if
				str2num
				[ ( off=) 2 index ] aprintVerbose
				b4 { /ttfhtbllen trap } if
				str2num
				[ ( len=) 2 index (\n) ] aprintVerbose
			] put
		} repeat

		a subfontnum ttftable put
		ttftable begin
		/File f def
		/Offset offset def
		/SubFontID subfontnum def
		end
		ttftable end
	} ifelse
} bind def

% ttfdict name <ttfPrepareTable> ttfdict dict bool
/ttfPrepareTable {
	2 copy get dup type /arraytype eq {
		1 dict begin
			/ttf 3 index def
			/f ttf /File get def
			/b2 f 2 bindfilebuffer def
			/b4 f 4 bindfilebuffer def
			1 dict begin
				aload pop
				/Length exch def
				/Offset exch def
				/Tag exch def
				[ Tag (: off=) Offset ] aprintDebug
				f Offset setfileposition
				ttf Tag currentdict put
			currentdict end
		true
	} {
		exch pop false
	} ifelse
} bind def

% ttfdict <ttfReadNameTable> ttfdict namedict
/ttfReadNameTable {
	/name ttfPrepareTable { % begin dict
		begin
		b2 { /ttfnamefmt trap } if
		str2num [ ( format=) 2 index ] aprintDebug
		dup 0 eq {
			pop
			b2 { /ttfnamecount trap } if
			str2num /Count exch def
			[ ( cnt=) Count ] aprintDebug
			Count MaxNamesPerFonts gt { /ttfnamecount0 trap } if
			b2 { /ttfnamestroff trap } if
			str2num Offset add /StringOffset exch def
			[ ( stroff=) StringOffset (\n) ] aprintDebug
			Count array /NameRecord exch def
			NameRecord {
				[ (  ) 2 index (: ) ] aprintVerbose
				<<
				/PlatformID b2 { /ttfnamepid trap } if str2num
				[ (platform=) 2 index ] aprintVerbose
				/EncodingID b2 { /ttfnameeid trap } if str2num
				[ ( enc=) 2 index ] aprintVerbose
				/LanguageID b2 { /ttfnamelid trap } if str2num
				[ ( lang=) 2 index ] aprintVerbose
				/NameID b2 { /ttfnamenid trap } if str2num
				[ ( nameid=) 2 index ] aprintVerbose
				/Length b2 { /ttfnamelen trap } if str2num
				[ ( len=) 2 index ] aprintVerbose
				/String b2 { /ttfnameoff trap } if str2num StringOffset add
				[ ( off=) 2 index (\n) ] aprintVerbose
				>> put
			} for-array
		} {
			/ttfnamefmt0 trap
		} ifelse
		currentdict end
	end } if
} bind def

% decode table for platform ID 3
/ttfNameDecodePF3 <<
	1 { decodeUCS2 }
	10 { decodeUCS4 }
>> def

% dict <ttfGetDecodeTable> ( decodeproc true | false )
%	using PlatformID and EncodingID in dict.
/ttfGetDecodeTable {
	begin
	1 {
		PlatformID 3 eq {	% Windows
			//ttfNameDecodePF3 EncodingID knownget exit
		} if
		false
	} repeat
	end
} bind def

% ttfdict <ttfReadFontName> ttfdict str
/ttfReadFontName {
	1 dict begin
	/f 1 index /File get def
	/got false def

	ttfReadNameTable	% ttfdict namedict
	/NameRecord get {
		dup /NameID get 6 eq {
			dup ttfGetDecodeTable { /got true def exit } if
		} if
		pop
	} forall
	got not { /ttfrdfn0 trap } if
	/decproc exch def

	begin
	String dup type /integertype eq {
		[ (  fontname: off=) 2 index ] aprintDebug
		f exch setfileposition
		f Length string readstring not { /ttfdfn1 trap } if
		[ /decproc loadexec /encodeUTF8 loadexec ] cvx convertstring
		dup /String exch def
		[ ( string=) String (\n) ] aprintDebug
	} if
	end
	end
} bind def

% font <ttfFindFontTable> (ttfdict true) | false
/ttfFindFontTable {
	1 dict begin
	dup /CIDFontName get /FontNickName exch def
	/FontName get /FontRealName exch def
	[ (ttfFindFontTable: FontName=) FontRealName ] aprintDebug
	[ ( CIDFontName=) FontNickName (\n) ] aprintDebug
	/got false def
	/CIDFont /Category findresource begin
	FontNickName MaxStringBuffer string ResourceFileName
	end
	[ (  filename=) 2 index (\n) ] aprintDebug
	(r) file /File exch def
	File ttfReadTTCHeader {	% file array subfontid
		ttfReadTrueTypeHeader	% ttfdict
		ttfReadFontName	% ttfdict str
		dup FontRealName eq { pop /got true def exit } if	% ttfdict
		FontNickName eq { /got true def exit } if	% ttfdict
		pop File	% file
	} for-array	% ttfdict | file
	got { true } { closefile false } ifelse
	end
} bind def

% ttfdict <ttfRead-head> ttfdict
% 	head table specific informations are stored in head dict.
%	global informations are stored in ttfdict directly.
/ttfReadHeadTable {
	/head ttfPrepareTable { % begin dict
		begin
			b4 { /ttfhead-ver0 trap } if
			str2num /Version exch def
			{ ( ver=) print Version ttfPrintVersion } ttfprocDebug
			Version 16#00010000 lt { /ttfhead-ver1 trap } if
		end
		ttf begin
			f 14 forward
			b2 { /ttfhead-em trap } if str2num
			/FUnit exch def
			[ ( funit=) FUnit (\n) ] aprintDebug
		end
	end } {
		pop
	} ifelse
} bind def

% ttfdict <ttfReadMaxpTable> ttfdict
% 	maxp table specific informations are stored in maxp dict.
%	global informations are stored in ttfdict directly.
/ttfReadMaxpTable {
	/maxp ttfPrepareTable { % begin currentdict
		begin
			b4 { /ttfmaxp-ver0 trap } if
			str2num /Version exch def
			{ ( ver=) print Version ttfPrintVersion } ttfprocDebug
			Version 16#00005000 lt { /ttfmaxp-ver1 trap } if
		end
		ttf begin
			b2 { /ttfmaxp-ng trap } if
			str2num /NumGlyphs exch def
			[ ( numglyphs=) NumGlyphs (\n) ] aprintDebug
		end
	end } {
		pop
	} ifelse
} bind def

% ttfdict <ttfReadHheaTable> ttfdict hheadict
/ttfReadHheaTable {
	/hhea ttfPrepareTable {
		begin
			b4 { /ttfhhea-ver0 trap } if
			str2num /Version exch def
			{ ( ver=) print Version ttfPrintVersion } ttfprocDebug
			Version 16#00010000 lt { /ttfhhea-ver1 trap } if
			f 28 forward
			b2 { /ttfhhea-format trap } if
			str2num /MetricDataFormat exch def
			[ ( format=) MetricDataFormat ] aprintDebug
			b2 { /ttfhhea-numhmtx trap } if
			str2num /NumberOfMetrics exch def
			[ ( numhmtx=) NumberOfMetrics (\n) ] aprintDebug
		currentdict end
	end } if
} bind def

/neareq {
	2 copy mul 0 lt {
		pop pop false
	} {
		div 1 sub abs 1e-5 lt
	} ifelse
} bind def

% ttfdict array headdict <ttfReadMetricsTable> ttfdict metricsdict
%	metrics values are normalized.
/ttfReadMetricsTable {
	1 dict begin
	dup /MetricDataFormat get 0 ne { /mtx-format trap } if
	/NumberOfMetrics get /m exch def
	/ttf 2 index def
	/f ttf /File get def
	/b2 f 2 bindfilebuffer def
	ttf ttfReadHeadTable
	dup /FUnit get /fu exch def
	ttfReadMaxpTable
	/NumGlyphs get /n exch def
	1 dict begin
		aload pop
		/Length exch def
		/Offset exch def
		[ (  metrics: off=) Offset (\n) ] aprintDebug
		/AdvanceDistance m array def
		f Offset setfileposition
		[ (  values:) ] aprintMoreVerbose
		AdvanceDistance {
			b2 { /ttfmtx-advdst trap } if
			str2num fu div
			[ ( ) 2 index ] aprintMoreVerbose
			put
			b2 { /ttfmtx-bearing trap } if pop
		} for-array
		[ (\n) ] aprintMoreVerbose
	currentdict end
	end
} bind def

% ttfdict <ttfReadHmtxTable> ttfdict hmtxdict
/ttfReadHmtxTable {
	dup /hmtx get dup type /arraytype eq {
		1 index ttfReadHheaTable exch pop
		(hmtx: reading ...\n) aprintDebug
		ttfReadMetricsTable
		2 copy /hmtx exch put
	} if
} bind def

% ttfdict <ttfReadVheaTable> ttfdict vheaddict
/ttfReadVheaTable {
	/vhea ttfPrepareTable {
		begin
			b4 { /ttfvhea-ver0 trap } if
			str2num /Version exch def
			{ ( ver=) print Version ttfPrintVersion } ttfprocDebug
			Version 16#00010000 lt { /ttfvhea-ver1 trap } if
			f 28 forward
			b2 { /ttfvhea-format trap } if
			str2num /MetricDataFormat exch def
			[ ( format=) MetricDataFormat ] aprintDebug
			b2 { /ttfvhea-numhmtx trap } if
			str2num /NumberOfMetrics exch def
			[ ( numvmtx=) NumberOfMetrics ] aprintDebug
			(\n) aprintDebug
		currentdict end
	end } if
} bind def

% ttfdict <ttfReadVmtxTable> ttfdict vmtxdict
/ttfReadVmtxTable {
	dup /vmtx get dup type /arraytype eq {
		1 index ttfReadVheaTable exch pop
		(vmtx: reading ...\n) aprintDebug
		ttfReadMetricsTable
		2 copy /vmtx exch put
	} if
} bind def

% ttfdict comdict name <ttfPrepareTable> ttfdict comdict dict bool
/ttfPrepareCommonTable {
	2 copy get dup type /integertype eq {
		1 dict begin
			/ttf 4 index def
			/comdic 3 index def
			/f ttf /File get def
			/b2 f 2 bindfilebuffer def
			/b4 f 4 bindfilebuffer def
			1 dict begin
				/Offset exch def
				/Tag exch def
				[ Tag (: off=) Offset ] aprintDebug
				f Offset setfileposition
				comdic Tag currentdict put
			currentdict end
		true
	} {
		exch pop false
	} ifelse
} bind def

% ttfdict comtbldict <ttfReadScriptList> ttfdict comtbldict slstdict
/ttfReadScriptList {
	/ScriptList ttfPrepareCommonTable {
		begin
			b2 { /ttfscript-count trap } if
			str2num /ScriptCount exch def
			[ ( cnt=) ScriptCount ] aprintDebug
			/ScriptRecord ScriptCount dict def
			(\n) aprintDebug
			ScriptRecord begin
				ScriptCount {
					b4 { /ttfscript-tag trap } if
					[ (  tag=) 2 index ] aprintVerbose
					cvn
					currentdict 1 index known { /ttfscript-dup trap } if
					b2 { /ttfscript-off trap } if
					str2num Offset add
					[ ( off=) 2 index ] aprintVerbose
					def
					(\n) aprintVerbose
				} repeat
			end
		currentdict end
	end } if
} bind def

% ttfdict comdict slstdict scriptid <ttfReadScriptTable>
%	ttfdict comdict stbldict
/ttfReadScriptTable {
	exch /ScriptRecord get exch 2 copy get dup type /integertype eq {
		1 dict begin
			/ttf 5 index def
			/f ttf /File get def
			/b2 f 2 bindfilebuffer def
			/b4 f 4 bindfilebuffer def
			/defaultpos null def
			1 dict begin
				/Offset exch def
				/Tag exch def
				[ Tag (: off=) Offset ] aprintDebug
				f Offset setfileposition
				Tag currentdict put
				b2 { /ttfscrtbl-deflang trap } if
				/TotalCount 0 def
				str2num dup 0 ne {
					Offset add /defaultpos exch store
					[ ( deflang=) defaultpos ] aprintDebug
					/TotalCount 1 def
				} {
					pop
				} ifelse
				b2 { /ttfscrtbl-count trap } if
				str2num /LangSysCount exch def
				[ ( cnt=) LangSysCount ] aprintDebug
				/TotalCount TotalCount LangSysCount add def
				[ ( total=) TotalCount ] aprintDebug
				/LangSysRecord TotalCount dict def
				(\n) aprintDebug
				LangSysRecord begin
					defaultpos type /integertype eq {
						/default defaultpos def
					} if
					LangSysCount {
						b4 { /ttfscrtbl-langtag trap } if
						[ (  tag=) 2 index ] aprintVerbose
						cvn
						b2 { /ttfscrtbl-langoff trap } if
						str2num Offset add
						[ ( off=) 2 index ] aprintVerbose
						(\n) aprintVerbose
						def
					} repeat
				end
			currentdict end
		end
	} {
		3 -2 roll pop pop
	} ifelse
} bind def

% ttfdict comdict stbldict langid <ttfReadLangSysTable>
%	ttfdict comdict langdict
/ttfReadLangSysTable {
	exch /LangSysRecord get exch 2 copy get dup type /integertype eq {
		1 dict begin
			/ttf 5 index def
			/f ttf /File get def
			/b2 f 2 bindfilebuffer def
			/b4 f 4 bindfilebuffer def
			1 dict begin
				/Offset exch def
				/Tag exch def
				[ Tag (: off=) Offset ] aprintDebug
				f Offset setfileposition
				Tag currentdict put
				b2 { /ttflangsys-order0 trap } if
				str2num 0 ne { /ttflangsys-order1 trap } if
				b2 { /ttflangsys-reqidx trap } if
				str2num /ReqFeatureIndex exch def
				[ ( reqidx=) ReqFeatureIndex ] aprintDebug
				b2 { /ttflangsys-count trap } if
				str2num /FeatureCount exch def
				[ ( cnt=) FeatureCount ] aprintDebug
				(\n  features:) aprintVerbose
				/FeatureIndex [
					FeatureCount {
						b2 { /ttflangsys-index trap } if
						str2num
						[ ( ) 2 index ] aprintVerbose
					} repeat
				] def
				(\n) aprintDebug
			currentdict end
		end
	} {
		3 -2 roll pop pop
	} ifelse
} bind def

% ttfdict comdict <ttfReadFeatureList> ttfdict comdict featuredict
/ttfReadFeatureList {
	/FeatureList ttfPrepareCommonTable {
		begin
			b2 { /ttffeature-count trap } if
			str2num /FeatureCount exch def
			[ ( cnt=) FeatureCount ] aprintDebug
			/FeatureRecord FeatureCount array def
			(\n) aprintDebug
			FeatureRecord {
				[ (  ) 2 index (:) ] aprintVerbose
				[
					b4 { /ttffeature-tag trap } if
					[ ( tag=) 2 index ] aprintVerbose
					cvn
					b2 { /ttffeature-off trap } if
					str2num Offset add
					[ ( off=) 2 index ] aprintVerbose
				] put
				(\n) aprintVerbose
			} for-array
		currentdict end
	end } if
} bind def

% ttfdict comdict fturpair <ttfReadFeatureTable> ttfdict comdict fturdict
/ttfReadFeatureTable {
	dup 1 get dup type /integertype eq {
		% ttf com pair off
		1 dict begin
			/ttf 4 index def
			/comdict 3 index def
			/f ttf /File get def
			/b2 f 2 bindfilebuffer def
			1 dict begin
				/Offset exch def	% ttf com pair
				[ (featuretable: off=) Offset ] aprintDebug
				f Offset setfileposition
				dup 0 get /Tag exch def
				[ ( tag=) Tag ] aprintDebug
				1 currentdict put	% ttf com
				b2 { /ttffturtbl-params trap } if
				str2num /FeatureParams exch def
				[ ( params=) FeatureParams ] aprintDebug
				FeatureParams 0 ne { /ttffturtbl-params1 trap } if
				b2 { /ttffturtbl-count trap } if
				str2num /LookupCount exch def
				[ ( cnt=) LookupCount ] aprintDebug
				/LookupListIndex LookupCount array def
				[ (\n  index:) ] aprintVerbose
				LookupListIndex {
					b2 { /ttffturtbl-index trap } if
					str2num [ ( ) 2 index ] aprintVerbose
					put
				} for-array
				[ (\n) ] aprintDebug
			currentdict end
		end
	} {
		exch pop
	} ifelse
} bind def

% ttfdict comdict <ttfReadLookupListTable> ttfdict comdict ludict
/ttfReadLookupListTable {
	/LookupList ttfPrepareCommonTable {
		begin
			b2 { /ttflookup-count trap } if
			str2num /LookupCount exch def
			[ ( cnt=) LookupCount ] aprintDebug
			(\n  offsets:) aprintVerbose
			/Lookup [ LookupCount {
				b2 { /ttflookup-off trap } if
				str2num Offset add
				[ 1 index ( ) ] aprintVerbose
			} repeat ] def
			(\n) aprintDebug
		currentdict end
	end } if
} bind def

% ttfdict comdict luidx <ttfReadLookupTable> ttfdict comdict lutdict
/ttfReadLookupTable {
	1 dict begin
	/luidx exch def
	ttfReadLookupListTable /Lookup get /lu exch def
	lu luidx get dup type /integertype eq {
		% ttfdict comdict offset
		[ (LookupTable: idx=) luidx ] aprintDebug
		/ttf 3 index def
		/f ttf /File get def
		/b2 f 2 bindfilebuffer def
		1 dict begin
			/Offset exch def
			[ ( off=) Offset ] aprintDebug
			f Offset setfileposition
			b2 { /ttflut-type trap } if
			str2num /LookupType exch def
			[ ( type=) LookupType ] aprintDebug
			b2 { /ttflut-flag trap } if
			str2num /LookupFlag exch def
			[ ( flag=) LookupFlag ] aprintDebug
			b2 { ttflut-count trap } if
			str2num /SubTableCount exch def
			[ ( cnt=) SubTableCount ] aprintDebug
			(\n  offsets:) aprintVerbose
			/SubTable [ SubTableCount {
				b2 { /ttflut-off trap } if
				str2num Offset add
				[ ( ) 2 index ] aprintVerbose
			} repeat ] def
			LookupFlag 16#10 and 0 ne {
				(\n ) aprintVerbose
				b2 { /ttflut-filt trap } if
				str2num /MarkFilteringSet exch def
				[ ( filt=) MarkFilteringSet ] aprintDebug
			} if
			(\n) aprintDebug
		currentdict end
	} if
	end
} bind def

% ttfdict <ttfReadGSUBTable> ttfdict gsubdict
/ttfReadGSUBTable {
	/GSUB ttfPrepareTable {
		begin
			b4 { /ttfGSUB-ver0 trap } if
			str2num /Version exch def
			{ ( ver=) print Version ttfPrintVersion } ttfprocDebug
			Version 16#00010000 lt { /ttfvhea-ver1 trap } if
			b2 { /ttfGSUB-scriptoff trap } if
			str2num Offset add /ScriptList exch def
			[ ( script=) ScriptList ] aprintDebug
			b2 { /ttfGSUB-featureoff trap } if
			str2num Offset add /FeatureList exch def
			[ ( feature=) FeatureList ] aprintDebug
			b2 { /ttfGSUB-lookupoff trap } if
			str2num Offset add /LookupList exch def
			[ ( lookup=) LookupList ] aprintDebug
			(\n) aprintDebug
		currentdict end
	end } if
} bind def

% ttfdict scriptid langid featureid <ttfFindGSUBTable>
%	ttfdict comtbl fturpair true
%	ttfdict false
/ttfFindGSUBTable {
	3 dict begin
	/feature exch def
	/lang exch def
	/script exch def
	/ttf 1 index def
	/got false def
	1 {
		ttf /GSUB known not { exit } if
		ttfReadGSUBTable	% ttfdict gsubdict
		ttfReadFeatureList /FeatureRecord get /fturrec exch def
		% ttfdict gsubdict
		ttfReadScriptList	% ttfdict gsubdict scrlstdict
		dup /ScriptRecord get script known not { pop pop exit } if
		script ttfReadScriptTable /scrtbl exch def	% ttfdict gsubdict
		[ lang /default ] {
			/id exch def
			scrtbl /LangSysRecord get id known {
				% ttfdict gsubdict
				scrtbl id ttfReadLangSysTable /FeatureIndex get {
					% ttfdict gsubdict fturidx
					fturrec exch get dup 0 get feature eq {
						% ttfdict gsubdict fturpair
						/got true def exit
					} if
					pop
				} forall
				% ttfdict gsubdict ( | fturpair )
			} if
			got { exit } if
		} forall
		got { exit if } if
		pop
	} repeat
	got
	end
} bind def

% file offset <ttfReadCoverageTable> dict
%	dict: glyphid to coverage index
/ttfReadCoverageTable {
	1 dict begin
	/offset exch def
	/f exch def
	/b2 f 2 bindfilebuffer def
	[ (coverage: off=) offset ] aprintDebug
	f offset setfileposition
	b2 { /ttfcov-fmt0 trap } if
	str2num /format exch def
	[ ( fmt=) format ] aprintDebug
	format 1 eq {
		b2 { /ttfcov-fmt1a trap } if
		str2num /gcnt exch def
		[ ( cnt=) gcnt ] aprintDebug
		(\n  cov:) aprintMoreVerbose
		<< 0 1 gcnt 1 sub {
			b2 { /ttfcov-fmt1b trap } if
			str2num exch
			[ ( ) 3 index ] aprintMoreVerbose
		} for >>
		(\n) aprintDebug
	} { format 2 eq {
		b2 { /ttfcov-fmt2a trap } if
		str2num /rcnt exch def
		[ ( cnt=) rcnt ] aprintDebug
		<< rcnt {
			b2 { /ttfcov-fmt2b trap } if
			str2num /startgid exch def
			b2 { /ttfcov-fmt2c trap } if
			str2num /endgid exch def
			b2 { /ttfcov-fmt2d trap } if
			str2num /startcov exch def
			[ (\n  cov: start=) startgid ( end=) endgid ( idx=) startcov ]
			aprintVerbose
			(\n    ->) aprintMoreVerbose
			startgid 1 endgid {
				dup startcov add startgid sub
				[ ( ) 3 index ] aprintMoreVerbose
			} for
		} repeat >>
		(\n) aprintDebug
	} {
		/ttfcov-fmt1 trap
	} ifelse } ifelse
	end
} bind def

% ttfdict gsubdict lutdict <ttfReadGSUBLookupSubTable> ttfdict gsubdict dict
%	gsub-subst-dict:
%		SubstFormat: substitution format
%		Coverage: coverage table dict. key=gid, value=covidx
%		destination gid is:
%		SubstFormat 1:
%			lookup Coverage by gid in qurey, add DeltaGlyphID to the result.
%		SubstFormat 2:
%			lookup Coverage by gid in query, lookup Substitute by the result.
/ttfReadGSUBLookupSubTable {
	1 dict begin
	/lu exch def
	/gsub 1 index def
	/ttf 2 index def
	lu /LookupType get 1 eq {
		(gsub-lutsub: type=1) aprintDebug
		lu /SubTable get {
			2 copy get dup type /integertype eq {
				/f ttf /File get def
				/b2 f 2 bindfilebuffer def
				1 dict begin
					/Offset exch def
					[ ( off=) Offset ] aprintDebug
					f Offset setfileposition
					currentdict put
					b2 { /ttfgsublutsub-substtype trap } if
					str2num /SubstFormat exch def
					[ ( fmt=) SubstFormat ] aprintDebug
					SubstFormat 1 eq {
						b2 { /ttfgsublutsub1-cov trap } if
						str2num Offset add /Coverage exch def
						[ ( cov=) Coverage ] aprintDebug
						b2 { /ttfgsublutsub1-delta trap } if
						str2num /DeltaGlyphID exch def
						[ ( delta=) DeltaGlyphID ] aprintDebug
					} { SubstFormat 2 eq {
						b2 { /ttfgsublutsub1-cov trap } if
						str2num Offset add /Coverage exch def
						[ ( cov=) Coverage ] aprintDebug
						b2 { /ttfgsublutsub1-gcnt trap } if
						str2num /GlyphCount exch def
						[ ( cnt=) GlyphCount ] aprintDebug
						(\n  subst:) aprintMoreVerbose
						/Substitute [ GlyphCount {
							b2 { /ttfgsublutsub1-gcnt trap } if
							str2num [ ( ) 2 index ] aprintMoreVerbose
						} repeat ] def
						(\n) aprintDebug
					} {
						/ttfgsublutsub-subfmt trap
					} ifelse } ifelse
					f Coverage ttfReadCoverageTable
					/Coverage exch def
					currentdict GlyphCount known {
						Coverage length GlyphCount ne {
							/ttfgsublutsub-covcnt trap
						} if
					} if
				currentdict end
			} {
				3 -2 roll pop pop
			} ifelse
		} for-array
	} {
		/ttfgsublutsub-luttype trap
	} ifelse
	end
} bind def

% ttfdict <ttfCloseFontFile> -
/ttfCloseFontFile {
	begin
	File type /filetype eq {
		(ttfCloseFontFile: closing file\n) aprintDebug
		File closefile
		/File null def
	} if
	end
} bind def

% ttfdict scptid langid fturid <ttfGetGSUBTable>
%	ttfdict arrayofsubstdict true |
%	ttfdict false
/ttfGetGSUBTable {
	ttfFindGSUBTable {
		% ttfdict gsubdict fturpair
		1 dict begin
		/ttf 3 index def
		ttfReadFeatureTable
		/fturdict exch def
		ttfReadLookupListTable
		/ludict exch def
		[ 3 -2 roll
		fturdict /LookupListIndex get {
			% ... ttfdict gsubdict luidx
			ttfReadLookupTable
			% ... ttfdict gsubdict lutdict
			ttfReadGSUBLookupSubTable
			% ... ttfdict gsubdict substdict
			3 -2 roll
			% ... substdict ttfdict gsubdict
		} forall
		% [ substdict ... ttfdict gsubdict
		pop pop ] ttf exch true
		end
	} {
		false
	} ifelse
} bind def

[ /MS-PGothic /IPAexMincho /DFPKaiSho-Md ] {
	(-----------------------------------------------------------------\n) print
	/CIDFont findresource ttfFindFontTable
	not { /ttf-notfound trap } if
	ttfReadHmtxTable pop
	dup /vmtx known { ttfReadVmtxTable pop } if
	/kana (JAN ) /vert ttfGetGSUBTable {
		== % array of dict
	} if
	ttfCloseFontFile
} forall
quit
