%!

/MaxFontsPerFile 1000 def
/MaxTablesPerFonts 1000 def
/MaxNamesPerFonts 1000 def
/MaxStringBuffer 256 def
/ttfprocDebug { exec } def
/ttfprocVerbose { pop } def

% name <loadexec> obj exec
/loadexec {
	load /exec cvx
} bind def

% <dict> <key> knownget ( <val> true ) | false
% knownget has same functionality as .knownget in GS.
/knownget {
	2 copy known { get true } { pop pop false } ifelse
} bind def

% <default> <dict> <key> tinydefaultget <val>
% return value for key in dict, if found.
% return default if else.
% order of parameter is different from defaultget in akamoz-util.ps
/tinydefaultget {
	knownget { exch pop } if
} bind def

% proc <protected-exec> -
%	dictionary stack is poped, execute proc,
%	then the dictionary stack is restored.
%	exit will be trapped. if exit is executed in proc, exit is re-executed,
%	and "exited" is set to true, false otherwise.
/protected-exec {
	1 {
		/exited true def
		[ /exec cvx currentdict ] cvx end exec
		/exited false put
	} [ /repeat cvx currentdict ] cvx exec begin
	exited { exit } if
} bind def

% array proc <for-array> -
%	procspec: array num <proc> -
/for-array {
	1 dict begin
	/p exch def
	/a exch def
	0 1 a length 1 sub {
		a exch /p load protected-exec
	} for
	end
} bind def

% array proc <for-array-reverse> -
%	procspec: array num <proc> -
/for-array-reverse {
	1 dict begin
	/p exch def
	/a exch def
	a length 1 sub -1 0 {
		a exch /p load protected-exec
	} for
	end
} bind def

% str num <splitstring> substrtail substrhead
/splitstring {
	2 dict begin
	/n exch def
	/s exch def
 	s n s length n sub getinterval
	s 0 n getinterval
	end
} bind def

% str <charbytes> num
/charbytesUTF8 {
	0 get
	dup 16#80 lt { 1 } {
	dup 16#c2 lt { /charbytesUTF8 trap } {
	dup 16#e0 lt { 2 } {
	dup 16#f0 lt { 3 } {
	dup 16#f8 lt { 4 } {
		/charbytesUTF8 trap	% default
	} ifelse } ifelse } ifelse } ifelse } ifelse
	exch pop
} bind def

/charbytesUCS2 {
	pop 2
} bind def

/charbytesUTF16BE {
	0 get
	dup 16#d8 lt { 2 } {
	dup 16#dc lt { 4 } {
	dup 16#e0 lt { /charbytesUTF16 trap } {
		2	% default
	} ifelse } ifelse } ifelse
} bind def

/charbytesUTF32 {
	pop 4
} bind def

% num <checkUnicode> num
/checkUnicode {
	dup 16#d800 lt { } {
	dup 16#e000 lt { /checkUnicode trap } {
	dup 16#110000 lt { } {
		/checkUnicode trap % default
	} ifelse } ifelse } ifelse
} bind def

% str <decode> num

/decodeUTF8Mask [ 16#ff 16#1f 16#0f 16#07 ] def
/decodeUTF8Limit [ 0 16#80 16#800 16#10000 ] def

% str <decodeUTF8> substrtail num
/decodeUTF8 {
	2 dict begin
	/s exch def
	s charbytesUTF8
	s 1 index splitstring pop exch
	1 sub /taillen exch def
	s 0 get //decodeUTF8Mask taillen get and
	s 1 taillen getinterval
	{
		dup 16#80 lt { /decodeUTF8b trap } if
		dup 16#c0 ge { /decodeUTF8c trap } if
		16#3f and exch 6 bitshift add
	} forall
	checkUnicode
	dup //decodeUTF8Limit taillen get lt { /decodeutf8d trap } if
	end
} bind def

currentdict /decodeUTF8Mask undef
currentdict /decodeUTF8Limit undef

% num <encodeUTF8> str
/encodeUTF8 {
	1 dict begin
	/u exch def
	u 16#80 lt {
		1 string dup 0 u put
	} {
		u 16#800 lt { 2 16#c0 } {
		u 16#10000 lt { 3 16#e0 } {
		u 16#110000 lt { 4 16#f0 } {
			/encodeUTF8 trap	% default
		} ifelse } ifelse } ifelse
		/msb exch def
		dup string exch
		1 sub -6 mul /bs exch def
		dup {
			u bs bitshift 16#3f and msb or put
			/msb 16#80 def
			/bs bs 6 add def
		} for-array
	} ifelse
	end
} bind def

% str <_decodeUCS2> num
/_decodeUCS2 {
	dup 1 get exch 0 get 8 bitshift add
} bind def

% str <decodeUCS2> substrtail num
/decodeUCS2 {
	2 splitstring
	_decodeUCS2
	checkUnicode
} bind def 

% str num <_encodeUCS2> str
/_encodeUCS2 {
	1 index 0 2 index -8 bitshift put
	1 index exch 1 exch 16#ff and put
} bind def

% num <encodeUCS2> str
/encodeUCS2 {
	checkUnicode
	dup 16#10000 ge { /encodeUCS2 trap } if
	2 string exch _encodeUCS2
} bind def

% str <decodeUTF16> substrtail num
/decodeUTF16 {
	2 splitstring _decodeUCS2
	dup 16#dc00 ge 1 index 16#e000 lt and { /decodeUTF16a trap } if
	dup 16#d800 ge 1 index 16#dc00 lt and {
		exch 2 splitstring _decodeUCS2	% hi substr lo
		dup 16#dc00 lt 1 index 16#e000 ge or { /decodeUTF16b trap } if
		3 -1 roll	% substr lo hi
		16#3ff and 10 bitshift exch 16#3ff and add 16#10000 add
	} if
	checkUnicode
} bind def

% num <encodeUTF16> str
/encodeUTF16 {
	checkUnicode
	dup 16#10000 lt {
		2 string exch _encodeUCS2
	} {
		16#10000 sub
		4 string exch
		dup 16#3ff and 16#dc00 add exch
		-10 bitshift 16#d800 add
		2 index 0 2 getinterval exch _encodeUCS2 pop
		1 index 2 2 getinterval exch _encodeUCS2 pop
	} ifelse
} bind def

% str <decodeUTF32> num
/decodeUTF32 {
	4 splitstring 0 exch {
		exch 8 bitshift add
	} forall
	checkUnicode
} bind def

% num <encodeUTF32> num
/encodeUTF32 {
	checkUnicode
	4 string exch 1 index {
		3 exch sub
		2 index 16#ff and put
		-8 bitshift
	} for-array
	pop
} bind def

% arrayofstr <concatallstring> str
/concatallstring {
	dup 0 exch { length add } forall
	string exch
	0 exch {
		dup length exch
		3 index exch 3 index exch putinterval
		add
	} forall pop
} bind def

% str dec-encproc <convertstring> str'
%	dec-encproc: str <dec-encproc> substrtail strchar
/convertstring {
	1 dict begin
	/decenc exch def
	[ exch {
		dup length 0 eq { exit } if
		/decenc load protected-exec exch
	} loop pop ]
	concatallstring
	end
} bind def

% <obj> <proc> exec-forall -
/exec-forall {
	1 index type /arraytype eq {
		forall
	} {
		1 exch repeat
	} ifelse
} bind def

% file num <forward> -
/forward {
	1 index fileposition add setfileposition
} bind def
% str <str2num> num
/str2num {
	0 exch { exch 8 bitshift add } forall
} bind def

/aprint-float-digits {
	dup 0.1 mul 0.05 add floor exch % div val
	1 index 10 mul sub round	% div mod
	dup 0 lt { pop (0) } {
	dup 9 gt { pop (9) } {
		cvi 1 string cvs	% default
	} ifelse } ifelse exch
} bind def

% num <aprint-float> -
/aprint-float {
	1 dict begin
	/val exch def
	F /fixed eq {
		[
			val 0 lt { (-) } if
			/val val abs def
			[
				P 0 gt {
					/e 10 P exp def
					val e mul round
					dup e div val ne {
						pop
						P { (0) } repeat
						val
					} {
						P { aprint-float-digits } repeat
					} ifelse
					(.) exch
				} {
					val
				} ifelse
				{ aprint-float-digits dup 0 eq { exit } if } loop
				pop
			] { get } for-array-reverse 
		] concatallstring
		dup length W exch sub dup 0 gt {
			{ ( ) print } repeat
		} {
			pop
		} ifelse
		print
	} {
		/aprint-float-format trap
	} ifelse
	end
} bind def

% array <aprint> -
% anyother <aprint> -
/aprint {
	1 dict begin
	/R 10 def
	/W 0 def
	/P 6 def
	/F /fixed def
	/Fill ( ) def
	{ 1 {
		dup type /integertype eq {
			R 32 string cvrs
			dup length W exch sub
			dup 0 gt { { Fill print } repeat } { pop } ifelse
			print
			exit
		} if
		dup type /realtype eq {
			aprint-float exit
		} if
		dup type /dicttype eq { { def } forall exit } if
		dup type /stringtype eq { print exit } if
		dup type /nametype eq { dup length string cvs print exit } if
		/aprint trap
	} repeat } exec-forall
	end
} bind def

/dstack {
	(--- ) print aprint ( ---\n) print
	pstack
	(---------\n) print flush
} bind def

% file num <bindfilebuffer> obj
/bindfilebuffer {
	[ 3 1 roll string /readstring cvx /not cvx ] cvx
} bind def

% file <ttfReadTTCHeader> file array
/ttfReadTTCHeader {
	1 dict begin
	dup 4 bindfilebuffer /b4 exch def
	dup fileposition
	b4 { /ttfc0 trap } if
	(ttcf) eq {
		% TrueType Collection
		{ (TrueType Collection: ) print } ttfprocDebug
		pop
		b4 { /ttfcver0 trap } if
		str2num 16#00010000 lt { /ttcfver1 trap } if
		b4 { /ttfcnumf0 trap } if
		str2num dup MaxFontsPerFile gt { /ttfcnumf1 trap } if
		{ (numfonts=) print dup aprint (\n) print } ttfprocDebug
		array dup {
			{ [ (  font ) 2 index (: ) ] aprint } ttfprocVerbose
			b4 { /ttcfoff0 trap } if str2num
			{ [ (offset=) 2 index (\n) ] aprint } ttfprocVerbose
			put
		} for-array
	} {
		% must be TrueType single font
		[ 0 ]
	} ifelse
	end
} bind def

% num <ttfPrintVersion> -
/ttfPrintVersion {
	[
		1 index -16 bitshift (.)
		<< /R 16 /W 4 /Fill (0) >> 4 index 16#ffff and
	] aprint
	pop
} bind def

% file array subfontnum <ttfReadTrueTypeHeader> ttfdict
/ttfReadTrueTypeHeader {
	3 array astore
	dup 1 get 1 index 2 get get dup type /integertype ne {
		exch pop
	} {
		% [ file array subfontnum ] offset
		1 dict begin
		/offset exch def
		aload pop
		/subfontnum exch def
		/a exch def
		/f exch def
		/ttftable 1 dict def
		/b4 f 4 bindfilebuffer def
		/b2 f 2 bindfilebuffer def
		f offset setfileposition

		{ [ (TrueType Offset Table: subfont=) subfontnum
			( offset=) offset ] aprint } ttfprocDebug
		b4 { /ttfhver0 trap } if
		str2num { dup ( version=) print ttfPrintVersion } ttfprocDebug
		16#00010000 ne { /ttfhver1 trap } if
		b2 { /ttfnumtbl0 trap } if
		str2num { [ ( numtables=) 2 index (\n) ] aprint } ttfprocDebug
		dup MaxTablesPerFonts gt { /ttfnumtbl1 trap } if
		f 6 forward
		{	% << name [ off len ] ... >>
			ttftable
			b4 { /ttfhtblid trap } if
			cvn { [ (  id=) 2 index ] aprint } ttfprocVerbose
			f 4 forward
			[
				b4 { /ttfhtbloff trap } if
				str2num
				{ [ ( offset=) 2 index ] aprint } ttfprocVerbose
				b4 { /ttfhtbllen trap } if
				str2num
				{ [ ( len=) 2 index (\n) ] aprint } ttfprocVerbose
			] put
		} repeat

		a subfontnum ttftable put
		ttftable begin
		/File f def
		/Offset offset def
		/SubFontID subfontnum def
		end
		ttftable end
	} ifelse
} bind def

% ttfdict <ttfReadNameTable> ttfdict namedict
/ttfReadNameTable {
	1 dict begin
	/ttf 1 index def
	ttf /name get dup type /arraytype eq {
		/f ttf /File get def
		/b2 f 2 bindfilebuffer def
		1 dict begin
		ttf /name currentdict put 
		aload pop
		/Length exch def
		/Offset exch def
		f Offset setfileposition
		b2 { /ttfnamefmt trap } if
		str2num
		{ [ (name: offset=) Offset ] aprint } ttfprocDebug
		{ [ ( format=) 2 index ] aprint } ttfprocDebug
		dup 0 eq {
			pop
			b2 { /ttfnamecount trap } if
			str2num /Count exch def
			{ [ ( count=) Count ] aprint } ttfprocDebug
			Count MaxNamesPerFonts gt { /ttfnamecount0 trap } if
			b2 { /ttfnamestroff trap } if
			str2num Offset add /StringOffset exch def
			{ [ ( stroff=) StringOffset (\n) ] aprint } ttfprocDebug
			Count array /NameRecord exch def
			NameRecord {
				{ [ (  ) 2 index (: ) ] aprint } ttfprocVerbose
				<<
				/PlatformID b2 { /ttfnamepid trap } if str2num
				{ [ (platform=) 2 index ] aprint } ttfprocVerbose
				/EncodingID b2 { /ttfnameeid trap } if str2num
				{ [ ( enc=) 2 index ] aprint } ttfprocVerbose
				/LanguageID b2 { /ttfnamelid trap } if str2num
				{ [ ( lang=) 2 index ] aprint } ttfprocVerbose
				/NameID b2 { /ttfnamenid trap } if str2num
				{ [ ( nameid=) 2 index ] aprint } ttfprocVerbose
				/Length b2 { /ttfnamelen trap } if str2num
				{ [ ( len=) 2 index ] aprint } ttfprocVerbose
				/String b2 { /ttfnameoff trap } if str2num StringOffset add
				{ [ ( off=) 2 index (\n) ] aprint } ttfprocVerbose
				>> put
			} for-array
		} {
			/ttfnamefmt0 trap
		} ifelse
		currentdict end
	} if
	end
} bind def

% decode table for platform ID 3
/ttfNameDecodePF3 <<
	1 { decodeUCS2 }
	10 { decodeUCS4 }
>> def

% dict <ttfGetDecodeTable> ( decodeproc true | false )
%	using PlatformID and EncodingID in dict.
/ttfGetDecodeTable {
	begin
	1 {
		PlatformID 3 eq {	% Windows
			//ttfNameDecodePF3 EncodingID knownget exit
		} if
		false
	} repeat
	end
} bind def

% ttfdict <ttfReadFontName> ttfdict str
/ttfReadFontName {
	1 dict begin
	/f 1 index /File get def
	/got false def

	ttfReadNameTable	% ttfdict namedict
	/NameRecord get {
		dup /NameID get 6 eq {
			dup ttfGetDecodeTable { /got true def exit } if
		} if
		pop
	} forall
	got not { /ttfrdfn0 trap } if
	/decproc exch def

	begin
	String dup type /integertype eq {
		f exch setfileposition
		f Length string readstring not { /ttfdfn1 trap } if
		[ /decproc loadexec /encodeUTF8 loadexec ] cvx convertstring
		dup /String exch def
	} if
	end
	end
} bind def

% font <ttfFindFontTable> (ttfdict true) | false
/ttfFindFontTable {
	1 dict begin
	/FontName get /FontName exch def
	/got false def
	/CIDFont /Category findresource begin
	FontName MaxStringBuffer string ResourceFileName
	end
	(r) file /File exch def
	File ttfReadTTCHeader {	% file array subfontid
		ttfReadTrueTypeHeader	% ttfdict
		ttfReadFontName	% ttfdict str
		FontName eq { /got true def exit } if	% ttfdict
		pop File	% file
	} for-array	% ttfdict | file
	got { true } { closefile false } ifelse
	end
} bind def

% ttfdict <ttfRead-head> ttfdict
% 	head table specific informations are stored in head dict.
%	global informations are stored in ttfdict directly.
/ttfReadHeadTable {
	/ttf 1 index def
	ttf /head get dup type /arraytype eq {
		1 dict begin
			/f ttf /File get def
			/b2 f 2 bindfilebuffer def
			/b4 f 4 bindfilebuffer def
			1 dict begin
				ttf /head currentdict put
				aload pop
				/Length exch def
				/Offset exch def
				f Offset setfileposition
				b4 { /ttfhead-ver0 trap } if str2num
				{ [ (head: offset=) Offset ( ver=) ] aprint } ttfprocDebug
				{ dup ttfPrintVersion } ttfprocDebug
				dup 16#00010000 lt { /ttfhead-ver1 trap } if
				/Version exch def
			end
			ttf begin
				f 14 forward
				b2 { /ttfhead-em trap } if str2num
				/FUnit exch def
				{ [ ( funit=) FUnit (\n) ] aprint } ttfprocDebug
			end
		end
	} {
		pop
	} ifelse
} bind def

% ttfdict <ttfReadMaxpTable> ttfdict
% 	maxp table specific informations are stored in maxp dict.
%	global informations are stored in ttfdict directly.
/ttfReadMaxpTable {
	/ttf 1 index def
	ttf /maxp get dup type /arraytype eq {
		1 dict begin
			/f ttf /File get def
			/b2 f 2 bindfilebuffer def
			/b4 f 4 bindfilebuffer def
			1 dict begin
				ttf /maxp currentdict put
				aload pop
				/Length exch def
				/Offset exch def
				f Offset setfileposition
				b4 { /ttfmaxp-ver0 trap } if str2num
				{ [ (maxp: offset=) Offset ( ver=) ] aprint } ttfprocDebug
				{ dup ttfPrintVersion } ttfprocDebug
				dup 16#00005000 lt { /ttfmaxp-ver1 trap } if
				/Version exch def
			end
			ttf begin
				b2 { /ttfmaxp-ng trap } if
				str2num /NumGlyphs exch def
				{ [ ( numglyphs=) NumGlyphs (\n) ] aprint } ttfprocDebug
			end
		end
	} {
		pop
	} ifelse
} bind def

% ttfdict <ttfReadHheaTable> ttfdict hheadict
/ttfReadHheaTable {
	/ttf 1 index def
	ttf /hhea get dup type /arraytype eq {
		1 dict begin
			/f ttf /File get def
			/b2 f 2 bindfilebuffer def
			/b4 f 4 bindfilebuffer def
			1 dict begin
				ttf /hhea currentdict put
				aload pop
				/Length exch def
				/Offset exch def
				f Offset setfileposition
				b4 { /ttfhhea-ver0 trap } if str2num
				{ [ (hhea: offset=) Offset ( ver=) ] aprint } ttfprocDebug
				{ dup ttfPrintVersion } ttfprocDebug
				dup 16#00010000 lt { /ttfhhea-ver1 trap } if
				/Version exch def
				f 28 forward
				b2 { /ttfhhea-format trap } if
				str2num /MetricDataFormat exch def
				{ [ ( format=) MetricDataFormat ] aprint } ttfprocDebug
				b2 { /ttfhhea-numhmtx trap } if
				str2num /NumberOfHMetrics exch def
				{ [ ( numhmtx=) NumberOfHMetrics (\n) ] aprint } ttfprocDebug
			currentdict end
		end
	} if
} bind def

% ttfdict <ttfReadHmtxTable> ttfdict hmtxdict
%	metrics values are normalized.
/ttfReadHmtxTable {
	/ttf 1 index def
	ttf /hmtx get dup type /arraytype eq {
		1 dict begin
			/f ttf /File get def
			/b2 f 2 bindfilebuffer def
			exch ttfReadHeadTable
			ttf /FUnit get /fu exch def
			ttfReadMaxpTable
			ttf /NumGlyphs get /n exch def
			ttfReadHheaTable
			dup /MetricDataFormat get 0 ne { /hmtx-format trap } if
			/NumberOfHMetrics get /m exch def
			exch
			1 dict begin
				ttf /hmtx currentdict put
				aload pop
				/Length exch def
				/Offset exch def
				/AdvanceWidth m array def
				f Offset setfileposition
				AdvanceWidth {
					b2 { /ttfhmtx-hmw } if
					str2num fu div [ 1 index ( ) ] aprint put
					b2 { /ttfhmtx-lsb } if pop
				} for-array
			currentdict end
		end
	} if
} bind def

% ttfdict <ttfCloseFontFile> -
/ttfCloseFontFile {
	begin
	/File type /filetype eq {
		File closefile
		/File null def
	} if
	end
} bind def

/MS-PGothic /CIDFont findresource ttfFindFontTable
not { /ttf-notfound trap } if
ttfReadHmtxTable
pop
ttfCloseFontFile
