%!

/ttfprocDebug { exec } def
/ttfprocVerbose { pop } def
/ttfprocMoreVerbose { pop } def
/aprintDebug { ttfprocDebug { aprint flush } ttfprocDebug } def
/aprintVerbose { ttfprocVerbose { aprint flush } ttfprocVerbose } def
/aprintMoreVerbose {
	ttfprocMoreVerbose { aprint flush } ttfprocMoreVerbose
} def

/MaxStringBuffer 256 def

% value object key [ vokput ] -
/vokput { 2 index put pop } bind def

% name <loadexec> obj exec
/loadexec {
	load /exec cvx
} bind def

% <dict> <key> knownget ( <val> true ) | false
% knownget has same functionality as .knownget in GS.
/knownget {
	2 copy known { get true } { pop pop false } ifelse
} bind def

% proc <protected-exec> -
%	dictionary stack is poped, execute proc,
%	then the dictionary stack is restored.
%	exit will be trapped. if exit is executed in proc, exit is re-executed,
%	and "exited" is set to true, false otherwise.
/protected-exec {
	1 {
		/exited true def
		[ /exec cvx currentdict ] cvx end exec
		/exited false put
	} [ /repeat cvx currentdict ] cvx exec begin
	exited { exit } if
} bind def

% array makeproc proc
%	this procedure cannot leave name as it is,
%	if it is not included in sub-clauses.
/makeproc {
	[ exch { dup type /nametype eq { cvx } if } forall ] cvx
} bind def

% <obj> <proc> exec-forall -
/exec-forall {
	1 index type /arraytype eq {
		forall
	} {
		1 exch repeat
	} ifelse
} bind def

% array proc <for-array> -
%	procspec: array num <proc> -
/for-array {
	1 dict begin
	/p exch def
	/a exch def
	0 1 a length 1 sub {
		a exch /p load protected-exec
	} for
	end
} bind def

% num proc <repeat-count> -
/repeat-count {
	exch 1 sub exch 0 1 4 2 roll for
} bind def

% - [ strbufCreate ] strbuf
/strbufCreate {
	<< /buf () /pos 0 >>
} def

% strbuf <strbufLength> int
/strbufLength {
	/pos get
} bind def

% strbuf len [ strbufRealloc ] -
/strbufRealloc {
	2 dict begin
	/len exch def
	/strbuf exch def
	strbuf /buf get length
	dup len lt {
		2 mul
		dup len lt { pop len } if
		{ (realloc to ) print dup == } pop
		string dup 0 strbuf /buf get putinterval strbuf /buf vokput
	} {
		pop
	} ifelse
	end
} bind def

% strbuf str [ strbufAppend ] -
/strbufAppend {
	1 index begin
	3 dict begin
	/str exch def
	/strbuf exch def
	/newlen pos str length add def
	strbuf newlen strbufRealloc
	buf pos str putinterval
	strbuf /pos newlen put
	end end
} bind def

% strbuf [ strbufGetString ] string
/strbufGetString {
	begin
	buf 0 pos getinterval
	end
} bind def

% str num <splitstring> substrtail substrhead
/splitstring {
	2 dict begin
	/n exch def
	/s exch def
 	s n s length n sub getinterval
	s 0 n getinterval
	end
} bind def

/aprint-float-digits {
	dup 0.1 mul 0.05 add floor exch % div val
	1 index 10 mul sub round	% div mod
	dup 0 lt { pop (0) } {
	dup 9 gt { pop (9) } {
		cvi 1 string cvs	% default
	} ifelse } ifelse exch
} bind def

/aprint-longval-divmod10 {
	1 dict begin
	/m 0 def
	/f true def
	[ exch {
		m 256 mul add dup 10 idiv exch
		10 mod /m exch def
		dup 0 eq f and { pop } if
		/f false def
	} forall ]
	m
	end
} bind def

% val width <aprint-float-fixed> str
/aprint-float-fixed {
	1 dict begin
	/prec exch def
	/val exch def
	/str strbufCreate def
	/s 1 string def

	% 符号
	val 0 lt {
		str (-) strbufAppend
		/val val abs def
	} if

	% 丸めておく
	/val val 10 prec neg exp 0.5 mul add def

	% 整数部と小数部に分ける
	/ipart val floor def
	/fpart val ipart sub def

	% 整数部を256進表現にする。
	/n 0 def
	{
		ipart 1 lt { exit } if
		/ipart ipart 256 div def
		/n n 8 add def
		n 5000 gt { /aprint-float-overflow trap } if
	} loop
	/ipart [ ipart n 8 idiv {
		256 mul dup floor cvi exch 1 index sub
	} repeat pop ] def

	% 下位桁から10進分解する。
	mark {
		ipart length 0 eq { exit } if
		ipart aprint-longval-divmod10 exch /ipart exch def
	} loop

	% 文字列に直す
	{
		dup mark eq { exit } if
		s cvs str exch strbufAppend
	} loop
	pop

	% 空っぽなら0を追加
	str strbufLength 0 eq { str (0) strbufAppend } if

	% 小数部
	str (.) strbufAppend
	fpart prec {
		10 mul dup floor dup cvi s cvs
		str exch strbufAppend
		sub
	} repeat pop

	str strbufGetString
	end
} bind def

% str align width aprint-align -
/aprint-align {
	2 index length	% str align width len
	sub	% str align width-len
	dup 0 le {
		pop pop print
	} { exch dup /right eq {	% str width-len align
		pop { ( ) print } repeat print
	} { dup /left eq {
		pop exch print { ( ) print } repeat
	} { type /stringtype eq {
		1 index 0 1 getinterval (-) eq {
			(-) print { A print } repeat
			1 1 index length 1 sub getinterval print
		} {
			{ A print } repeat print
		} ifelse
	} {
		/aprint-align trap
	} ifelse } ifelse } ifelse } ifelse
} def

% array <aprint> -
% anyother <aprint> -
/aprint {
	1 dict begin
	/W 0 def	% field width
	/P 6 def	% precision
	/A /right def	% align: /right, /left or string to fill
	/F /fixed def	% floating point format
	/R 10 def	% radix
	{ 1 {
		dup type /integertype eq { R 32 string cvrs A W aprint-align exit } if
		dup type /realtype eq { P aprint-float-fixed A W aprint-align exit } if
		dup type /dicttype eq { { def } forall exit } if
		dup type /nametype eq { dup length string cvs } if % fall through
		dup type /stringtype eq { A W aprint-align exit } if
		dup type /booleantype eq {
			{ (true) } { (false) } ifelse print exit
		} if
		/aprint trap
	} repeat } exec-forall
	end
} def

/dstack {
	(--- ) print aprint ( ---\n) print
	pstack
	(---------\n) print flush
} bind def

/ddump {
	(=== ) print aprint ( ===\n) print
	dup { exch aprint ( ) print == } forall
	(=========\n) print flush
} bind def

/dval {
	dup aprint (=) print load ==
} bind def

% str <charbytes> num
/charbytesUTF8 {
	0 get
	dup 16#80 lt { 1 } {
	dup 16#c2 lt { /charbytesUTF8 trap } {
	dup 16#e0 lt { 2 } {
	dup 16#f0 lt { 3 } {
	dup 16#f8 lt { 4 } {
		/charbytesUTF8 trap	% default
	} ifelse } ifelse } ifelse } ifelse } ifelse
	exch pop
} bind def

/charbytesUCS2 {
	pop 2
} bind def

/charbytesUTF16BE {
	0 get
	dup 16#d8 lt { 2 } {
	dup 16#dc lt { 4 } {
	dup 16#e0 lt { /charbytesUTF16 trap } {
		2	% default
	} ifelse } ifelse } ifelse
} bind def

/charbytesUTF32 {
	pop 4
} bind def

% num <checkUnicode> num
/checkUnicode {
	dup 16#d800 lt { } {
	dup 16#e000 lt { /checkUnicode trap } {
	dup 16#110000 lt { } {
		/checkUnicode trap % default
	} ifelse } ifelse } ifelse
} bind def

% str <decode> num

/decodeUTF8Mask [ 16#ff 16#1f 16#0f 16#07 ] def
/decodeUTF8Limit [ 0 16#80 16#800 16#10000 ] def

% str <decodeUTF8> substrtail num
/decodeUTF8 {
	2 dict begin
	/s exch def
	s charbytesUTF8
	s 1 index splitstring pop exch
	1 sub /taillen exch def
	s 0 get //decodeUTF8Mask taillen get and
	s 1 taillen getinterval
	{
		dup 16#80 lt { /decodeUTF8b trap } if
		dup 16#c0 ge { /decodeUTF8c trap } if
		16#3f and exch 6 bitshift add
	} forall
	checkUnicode
	dup //decodeUTF8Limit taillen get lt { /decodeutf8d trap } if
	end
} bind def

currentdict /decodeUTF8Mask undef
currentdict /decodeUTF8Limit undef

% num <encodeUTF8> str
/encodeUTF8 {
	1 dict begin
	/u exch def
	u 16#80 lt {
		1 string dup 0 u put
	} {
		u 16#800 lt { 2 16#c0 } {
		u 16#10000 lt { 3 16#e0 } {
		u 16#110000 lt { 4 16#f0 } {
			/encodeUTF8 trap	% default
		} ifelse } ifelse } ifelse
		/msb exch def
		dup string exch
		1 sub -6 mul /bs exch def
		dup {
			u bs bitshift 16#3f and msb or put
			/msb 16#80 def
			/bs bs 6 add def
		} for-array
	} ifelse
	end
} bind def

% str <_decodeUCS2> num
/_decodeUCS2 {
	dup 1 get exch 0 get 8 bitshift add
} bind def

% str <decodeUCS2> substrtail num
/decodeUCS2 {
	2 splitstring
	_decodeUCS2
	checkUnicode
} bind def 

% str num <_encodeUCS2> str
/_encodeUCS2 {
	1 index 0 2 index -8 bitshift put
	1 index exch 1 exch 16#ff and put
} bind def

% num <encodeUCS2> str
/encodeUCS2 {
	checkUnicode
	dup 16#10000 ge { /encodeUCS2 trap } if
	2 string exch _encodeUCS2
} bind def

% str <decodeUTF16> substrtail num
/decodeUTF16 {
	2 splitstring _decodeUCS2
	dup 16#dc00 ge 1 index 16#e000 lt and { /decodeUTF16a trap } if
	dup 16#d800 ge 1 index 16#dc00 lt and {
		exch 2 splitstring _decodeUCS2	% hi substr lo
		dup 16#dc00 lt 1 index 16#e000 ge or { /decodeUTF16b trap } if
		3 -1 roll	% substr lo hi
		16#3ff and 10 bitshift exch 16#3ff and add 16#10000 add
	} if
	checkUnicode
} bind def

% num <encodeUTF16> str
/encodeUTF16 {
	checkUnicode
	dup 16#10000 lt {
		2 string exch _encodeUCS2
	} {
		16#10000 sub
		4 string exch
		dup 16#3ff and 16#dc00 add exch
		-10 bitshift 16#d800 add
		2 index 0 2 getinterval exch _encodeUCS2 pop
		1 index 2 2 getinterval exch _encodeUCS2 pop
	} ifelse
} bind def

% str <decodeUTF32> num
/decodeUTF32 {
	4 splitstring 0 exch {
		exch 8 bitshift add
	} forall
	checkUnicode
} bind def

% num <encodeUTF32> num
/encodeUTF32 {
	checkUnicode
	4 string exch 1 index {
		3 exch sub
		2 index 16#ff and put
		-8 bitshift
	} for-array
	pop
} bind def

% arrayofstr <concatallstring> str
/concatallstring {
	dup 0 exch { length add } forall
	string exch
	0 exch {
		dup length exch
		3 index exch 3 index exch putinterval
		add
	} forall pop
} bind def

% str dec-encproc <convertstring> str'
%	dec-encproc: str <dec-encproc> substrtail strchar
/convertstring {
	1 dict begin
	/decenc exch def
	[ exch {
		dup length 0 eq { exit } if
		/decenc load protected-exec exch
	} loop pop ]
	concatallstring
	end
} bind def

% file num <forward> -
/forward {
	1 index fileposition add setfileposition
} bind def
% str <str2num> num
/str2num {
	0 exch { exch 8 bitshift add } forall
} bind def

% proc <moveverbose> -
/moreverbose {
	1 dict begin
	/CurrentVerbose /ttfprocVerbose load def
	/ttfprocVerbose /ttfprocMoreVerbose load store
	protected-exec
	/ttfprocVerbose /CurrentVerbose load store
	end
} bind def

% file num <bindfilebuffer> obj
/bindfilebuffer {
	[ 3 1 roll string /readstring /not { /readstring trap } /if ] makeproc
} bind def

1 dict begin % ttfprocUtility

/b2 /FontFile 2 bindfilebuffer def
/b4 /FontFile 4 bindfilebuffer def
/n2 { b2 str2num } bind def
/n4 { b4 str2num } bind def
/off2 { n2 Offset add } bind def
/setpos { FontFile exch setfileposition } bind def
/fwd { FontFile fileposition add setpos } bind def

/ckver {
	/Version b4 def
	{ ( ver=) print Version ttfPrintVersion } ttfprocDebug
	Version gt { /ttfver trap } if
} bind def

/ckdup {
	currentdict 1 index known { /ttf-duptag trap } if
} bind def

% obj key proc <retr> dict
% retrieve standard table
/retr {
	1 dict begin
	/p exch def
	/k exch def
	/o exch def
	o k get dup type /dicttype ne {
		1 dict begin
		o k currentdict put
		/Offset exch def
		true
	} { dup /Retrieved known not {
		begin true
	} {
		false
	} ifelse } ifelse
	{
		/Key k def
		[ Key (: off=) Offset ] aprintDebug
		Offset setpos p
		/Retrieved true def
		(\n) aprintDebug
		currentdict end
	} {
		[ k (: (cached)\n) ] aprintDebug
	} ifelse
	end
} bind def

% name num <idxtbl> -
/idxtbl {
	array exch 1 index def
	{
		n2 [ ( ) 2 index ] aprintVerbose put
	} for-array
} bind def

% name num <offtbl> -
/offtbl {
	array exch 1 index def
	{
		off2 [ ( ) 2 index ] aprintVerbose put
	} for-array
} bind def

% num <tagoff> -
/tagoff {
	{
		b4 cvn [ (\n  ) 2 index ] aprintVerbose ckdup
		off2 [ (: off=) 2 index ] aprintVerbose def
	} repeat
} bind def

currentdict end
/ttfprocUtility exch def

% file <ttfReadTTCHeader> otfdict
/ttfReadTTCHeader {
	//ttfprocUtility begin
	1 dict begin
	/FontFile exch def
	b4 (ttcf) eq {
		(TrueType Collection: ) aprintDebug
		<00010000> ckver
		/NumFonts n4 def
		[ ( numfonts=) NumFonts ] aprintDebug
		[ (\n  offsets:) ] aprintVerbose
		/OffsetTable [ NumFonts {
			n4 [ ( ) 2 index ] aprintVerbose
		} repeat ] def
	} {
		(TrueType single font (maybe)) aprintDebug
		/Version <00010000> def
		/NumFonts 1 def
		/OffsetTable [ 0 ] def
	} ifelse
	(\n) aprintDebug
	currentdict end end
} bind def

% str <ttfPrintVersion> -
/ttfPrintVersion {
	str2num [
		1 index -16 bitshift (.)
		<< /R 16 /W 4 /A (0) >> 4 index 16#ffff and
	] aprint
	pop
} bind def

% otfdict subfontnum <ttfReadTrueTypeHeader> ttfdict
/ttfReadTrueTypeHeader {
	1 index begin
	//ttfprocUtility begin
	1 dict begin
	/sf exch def
	/otf exch def
	(TrueType Offset Table ) aprintDebug
	OffsetTable sf {
		% copy utility procedures
		//ttfprocUtility currentdict copy
		/FontFile FontFile def
		<00010000> ckver
		/NumTables n2 def
		[ ( cnt=) NumTables ] aprintDebug
		6 fwd
		/OffsetTable NumTables dict def
		OffsetTable begin NumTables {
			b4 cvn [ (\n  ) 2 index ] aprintVerbose ckdup
			<<
				/Checksum n4
				[ (: sum=) << /R 16 /W 8 /A (0) >> 3 index ] aprintVerbose
				/Offset n4 [ ( off=) 2 index ] aprintVerbose
				/Length n4 [ ( len=) 2 index ] aprintVerbose
			>> def
		} repeat end
	} retr
	end end end exch pop
} bind def

% otfdict | ttfdict <ttfCloseFontFile> -
/ttfCloseFontFile {
	begin
	FontFile type /filetype eq {
		(ttfCloseFontFile: closing file\n) aprintDebug
		FontFile closefile
		/FontFile null def
	} if
	end
} bind def

% ttfdict <ttfReadNameTable> ttfdict namedict
/ttfReadNameTable {
	dup begin
	OffsetTable /name {
		/Format n2 def
		[ ( format=) Format ] aprintDebug
		Format 0 eq {
			/Count n2 def
			[ ( cnt=) Count ] aprintDebug
			/StringOffset off2 def
			[ ( stroff=) StringOffset ] aprintDebug
			/NameRecord Count array def
			NameRecord {
				[ (\n  ) 2 index (:) ] aprintVerbose
				<<
				/PlatformID n2
				[ ( platform=) 2 index ] aprintVerbose
				/EncodingID n2
				[ ( enc=) 2 index ] aprintVerbose
				/LanguageID n2
				[ ( lang=) 2 index ] aprintVerbose
				/NameID n2
				[ ( nameid=) 2 index ] aprintVerbose
				/Length n2
				[ ( len=) 2 index ] aprintVerbose
				/String n2 StringOffset add
				[ ( off=) 2 index ] aprintVerbose
				>> put
			} for-array
		} {
			/ttfnamefmt0 trap
		} ifelse
	} retr
	end
} bind def

% decode table for platform ID 3
/ttfNameDecodePF3 <<
	1 { decodeUCS2 }
	10 { decodeUCS4 }
>> def

/ttfNameDecode <<
	3 ttfNameDecodePF3
>> def

% dict <ttfGetDecodeTable> ( decodeproc true | false )
%	using PlatformID and EncodingID in dict.
/ttfGetDecodeTable {
	begin
	//ttfNameDecode PlatformID knownget dup { pop EncodingID knownget } if
	end
} bind def

% ttfdict <ttfGetFontName> ttfdict str
/ttfGetFontName {
	dup begin
	1 dict begin
	/got false def

	ttfReadNameTable	% ttfdict namedict
	/NameRecord get {
		dup /NameID get 6 eq {
			dup ttfGetDecodeTable { /got true def exit } if
		} if
		pop
	} forall
	got not { /ttfrdfn0 trap } if
	/decproc exch def

	begin
	String dup type /integertype eq {
		[ (  fontname: off=) 2 index ] aprintDebug
		setpos
		FontFile Length string readstring not { /ttfdfn1 trap } if
		[ /decproc loadexec /encodeUTF8 loadexec ] cvx convertstring
		dup /String exch def
		[ ( string=) String (\n) ] aprintDebug
	} if
	end end end
} bind def

% font <ttfFindFontTable> (ttfdict true) | false
/ttfFindFontTable {
	1 dict begin
	dup /CIDFontName get /FontNickName exch def
	/FontName get /FontRealName exch def
	[ (ttfFindFontTable: FontName=) FontRealName ] aprintDebug
	[ ( CIDFontName=) FontNickName (\n) ] aprintDebug
	/got false def
	/CIDFont /Category findresource begin
	FontNickName MaxStringBuffer string ResourceFileName
	end
	[ (  filename=) 2 index (\n) ] aprintDebug
	(r) file ttfReadTTCHeader /otf exch def
	otf /NumFonts get {	% otf subfontid
		otf exch ttfReadTrueTypeHeader	% ttfdict
		ttfGetFontName	% ttfdict str
		dup FontRealName eq { pop /got true def exit } if	% ttfdict str
		FontNickName eq { /got true def exit } if	% ttfdict
		pop
	} repeat-count	% ttfdict |
	got { true } { otf ttfCloseFontFile false } ifelse
	end
} bind def

% ttfdict id <ttfCheckSupport> ttfdict
/ttfCheckSupport {
	1 index /OffsetTable get exch known
} bind def

% ttfdict <ttfRead-head> ttfdict
% 	head table specific informations are stored in head dict.
%	global informations are stored in ttfdict directly.
/ttfReadHeadTable {
	dup begin
	OffsetTable /head {
		<00010000> ckver
		dup begin
			14 fwd /UnitsPerEm n2 def
			[ ( funit=) UnitsPerEm ] aprintDebug
		end
	} retr pop
	end
} bind def

% ttfdict <ttfReadMaxpTable> ttfdict
% 	maxp table specific informations are stored in maxp dict.
%	global informations are stored in ttfdict directly.
/ttfReadMaxpTable {
	dup begin
	OffsetTable /maxp {
		<00005000> ckver
		dup begin
			/NumGlyphs n2 def
			[ ( numglyphs=) NumGlyphs ] aprintDebug
		end
	} retr pop
	end
} bind def

% ttfdict <ttfReadHheaTable> ttfdict hheadict
/ttfReadHheaTable {
	dup begin
	OffsetTable /hhea {
		<00010000> ckver
		28 fwd
		/MetricDataFormat n2 def
		[ ( format=) MetricDataFormat ] aprintDebug
		/NumberOfMetrics n2 def
		[ ( numhmtx=) NumberOfMetrics ] aprintDebug
	} retr
	end
} bind def

% ttfdict ( hheadict | vheadict ) id <ttfReadMetricsTable> ttfdict mtxdict
%	metrics values are normalized.
/ttfReadMetricsTable {
	2 index begin
	1 dict begin
	/id exch def
	/xhea exch def
	xhea /MetricDataFormat get 0 ne { /mtx-format trap } if
	ttfReadHeadTable
	ttfReadMaxpTable
	OffsetTable id {
		/AdvanceDistance xhea /NumberOfMetrics get array def
		[ (\n  values:) ] aprintMoreVerbose
		AdvanceDistance {
			n2 UnitsPerEm div
			[ ( ) 2 index ] aprintMoreVerbose put
			2 fwd
		} for-array
	} retr
	end end
} bind def

% ttfdict <ttfReadHmtxTable> ttfdict hmtxdict
/ttfReadHmtxTable {
	ttfReadHheaTable
	/hmtx ttfReadMetricsTable
} bind def

% ttfdict <ttfReadVheaTable> ttfdict vheaddict
/ttfReadVheaTable {
	dup begin
	OffsetTable /vhea {
		<00010000> ckver
		28 fwd
		/MetricDataFormat n2 def
		[ ( format=) MetricDataFormat ] aprintDebug
		/NumberOfMetrics n2 def
		[ ( numvmtx=) NumberOfMetrics ] aprintDebug
	} retr
	end
} bind def

% ttfdict <ttfReadVmtxTable> ttfdict vmtxdict
/ttfReadVmtxTable {
	ttfReadVheaTable
	/vmtx ttfReadMetricsTable
} bind def

% ttfdict comdict id <ttfReadScriptList> ttfdict scrldict
/ttfReadScriptList {
	1 index begin
	/ScriptList {
		/ScriptCount n2 def
		[ ( cnt=) ScriptCount ] aprintDebug
		ScriptCount tagoff
	} retr
	end
} bind def

% ttfdict scrldict scriptid <ttfReadScriptTable> ttfdict scrtdict
/ttfReadScriptTable {
	2 index begin
	{
		/DefaultLangSys n2 dup 0 ne {
			Offset add dup /default exch def
		} if def
		[ ( deflang=) DefaultLangSys ] aprintDebug
		/LangSysCount n2 def
		[ ( cnt=) LangSysCount ] aprintDebug
		LangSysCount tagoff
	} retr
	end
} bind def

% ttfdict scrtdict langid <ttfReadLangSysTable> ttfdict langdict
/ttfReadLangSysTable {
	2 index begin
	(LangSysTable ) aprintDebug
	{
		n2 0 ne { /ttflangsys-luorder trap } if
		/ReqFeatureIndex n2 def
		[ ( reqidx=) ReqFeatureIndex ] aprintDebug
		/FeatureCount n2 def
		[ ( cnt=) FeatureCount ] aprintDebug
		(\n  fturidx:) aprintVerbose
		/FeatureIndex FeatureCount idxtbl
	} retr
	end
} bind def

% ttfdict comdict <ttfReadFeatureList> ttfdict ftrldict ftrrec
/ttfReadFeatureList {
	1 index begin
	/FeatureList {
		/FeatureCount n2 def
		[ ( cnt=) FeatureCount ] aprintDebug
		/FeatureRecord FeatureCount array def
		FeatureRecord {
			[ (\n  ) 2 index (:) ] aprintVerbose
			<< /Tag b4 cvn [ ( tag=) 2 index ] aprintVerbose
			/Offset off2 [ ( off=) 2 index ] aprintVerbose >> put
		} for-array
	} retr
	dup /FeatureRecord get
	end
} bind def

% ttfdict ftrrec idx <ttfReadFeatureTable> ttfdict ftrtdict luidxarray
/ttfReadFeatureTable {
	2 index begin
	(FeatureTable ) aprintDebug
	{
		/FeatureParams n2 def
		[ ( params=) FeatureParams ] aprintDebug
		FeatureParams 0 ne { /ttfftrt-params trap } if
		/LookupCount n2 def
		[ ( cnt=) LookupCount ] aprintDebug
		[ (\n  luplidx:) ] aprintVerbose
		/LookupListIndex LookupCount idxtbl
	} retr
	dup /LookupListIndex get
	end
} bind def

% ttfdict comdict <ttfReadLookupList> ttfdict lupldict luarray
/ttfReadLookupList {
	1 index begin
	/LookupList {
		/LookupCount n2 def
		[ ( cnt=) LookupCount ] aprintDebug
		(\n  offsets:) aprintVerbose
		/Lookup LookupCount offtbl
	} retr
	dup /Lookup get
	end
} bind def

% ttfdict luarray luidx <ttfReadLookupTable> ttfdict lutdict
/ttfReadLookupTable {
	2 index begin
	(LookupTable ) aprintDebug
	{
		/LookupType n2 def
		[ ( type=) LookupType ] aprintDebug
		/LookupFlag n2 def
		[ ( flag=) LookupFlag ] aprintDebug
		/SubTableCount n2 def
		[ ( cnt=) SubTableCount ] aprintDebug
		(\n  offsets:) aprintVerbose
		/SubTable SubTableCount offtbl
		LookupFlag 16#10 and 0 ne {
			/MarkFilteringSet n2 def
			[ (\n  filt=) MarkFilteringSet ] aprintDebug
		} if
	} retr
	end
} bind def

% ttf lsubdict covid <ttfReadCoverageTable> ttf lsubdict covdict
/ttfReadCoverageTable {
	2 index begin
	1 index exch
	{
		/CoverageFormat n2 def
		[ ( fmt=) CoverageFormat ] aprintDebug
		CoverageFormat 1 eq {
			/GlyphCount n2 def
			[ ( cnt=) GlyphCount ] aprintDebug
			(\n  cov:) aprintMoreVerbose
			/GlyphArray GlyphCount { idxtbl } moreverbose
			% create inverse table
			/CoverageLookup << GlyphArray {
				exch 1 index get exch
			} for-array >> def
		} { CoverageFormat 2 eq {
			/RangeCount n2 def
			[ ( cnt=) RangeCount ] aprintDebug
			/CoverageLookup << RangeCount {
				/Start n2 def
				[ (\n  cov: start=) Start ] aprintVerbose
				/End n2 def
				[ ( end=) End ] aprintVerbose
				/StartCoverageIndex n2 def
				[ ( idx=) StartCoverageIndex ] aprintVerbose
				(\n    ->) aprintMoreVerbose
				Start 1 End {
					dup StartCoverageIndex add Start sub
					[ ( ) 3 index ] aprintMoreVerbose
				} for
			} repeat >> def
		} {
			/ttfcov-fmt1 trap
		} ifelse } ifelse
	} retr
	end
} bind def

% ttfdict <ttfReadGSUBTable> ttfdict gsubdict
/ttfReadGSUBTable {
	dup begin
	OffsetTable /GSUB {
		<00010000> ckver
		/ScriptList off2 def
		[ ( script=) ScriptList ] aprintDebug
		/FeatureList off2 def
		[ ( feature=) FeatureList ] aprintDebug
		/LookupList off2 def
		[ ( lookup=) LookupList ] aprintDebug
	} retr
	end
} bind def

% substdict begin gid <ttfGSUBType1Subst*Lookup> gid' bool
/ttfGSUBType1Subst1Lookup {
	Coverage begin
	CoverageLookup 1 index known {
		DeltaGlyphID add 16#ffff and
		true
	} {
		false
	} ifelse
	end
} bind def

/ttfGSUBType1Subst2Lookup {
	Coverage begin
	CoverageLookup 1 index known {
		CoverageLookup exch get
		Substitute exch get
		true
	} {
		false
	} ifelse
	end
} bind def

% ttf subtblarray subtblidx <ttfReadGSUBLookupSubTable> ttf substdict
/ttfReadGSUBLookupType1SubTable {
	2 index begin
	(GSUB LookupType 1 SubTable ) aprintDebug
	{
		/SubstFormat n2 def
		[ ( fmt=) SubstFormat ] aprintDebug
		SubstFormat 1 eq {
			/Coverage off2 def
			[ ( cov=) Coverage ] aprintDebug
			/DeltaGlyphID n2 def
			[ ( delta=) DeltaGlyphID ] aprintDebug
			/Lookup /ttfGSUBType1Subst1Lookup load def
		} { SubstFormat 2 eq {
			/Coverage off2 def
			[ ( cov=) Coverage ] aprintDebug
			/GlyphCount n2 def
			[ ( cnt=) GlyphCount ] aprintDebug
			(\n  gids for substitute:) aprintMoreVerbose
			/Substitute GlyphCount { idxtbl } moreverbose
			/Lookup /ttfGSUBType1Subst2Lookup load def
		} {
			/ttf-gsub-subtbl trap
		} ifelse } ifelse
	} retr
	% read coverage
	/Coverage ttfReadCoverageTable pop
	end
} bind def

% ttf lutdict <ttfReadGSUBLookupSubTable> ttf lutdict substarray
/ttfReadGSUBLookupSubTable {
	1 index begin
	dup /LookupType get 1 eq {
		dup /SubTable get dup length array dup
		{	% ttf lutdict SubTable array array index
			5 index 4 index 2 index ttfReadGSUBLookupType1SubTable
			% ttf lutdict SubTable array array index ttf substdict
			exch pop put
		} for-array
		% ttf lutdict SubTable array
		exch pop
	} {
		/ttf-gsub-lookuptype trap
	} ifelse
	end
} bind def

% ttfdict scriptid langid featureid <ttfFindGSUBTable>
%	ttfdict ftrrec ftridx true
%	ttfdict false
/ttfFindGSUBTable {
	3 dict begin
	/feature exch def
	/lang exch def
	/script exch def
	/ttf 1 index def
	/got false def
	1 {
		/GSUB ttfCheckSupport not { (no GSUB table\n) aprintVerbose exit } if
		ttfReadGSUBTable /gsub exch def
		gsub ttfReadScriptList /scrlst exch def
		gsub ttfReadFeatureList /ftrrec exch def pop
		scrlst script known not {
			[ (no ) script (Script\n) ] aprintVerbose exit
		} if
		scrlst script ttfReadScriptTable /scrtbl exch def
		[ lang /default ] {
			/id exch def
			scrtbl id known {
				scrtbl id ttfReadLangSysTable
				(Enumerate FeatureIndex:) aprintVerbose
				/FeatureIndex get {
					[ (\n  fidx=) 2 index ] aprintVerbose
					ftrrec 1 index get /Tag get
					[ ( tag=) 2 index ] aprintVerbose
					feature eq {
						/ftridx exch def
						/got true def
						(, found\n) aprintVerbose
						exit
					} if
					pop
				} forall
			} {
				[ (LangSysTable ) id ( is not found.\n) ] aprintVerbose
			} ifelse
			got { exit } if
		} forall
		got { exit } if
	} repeat
	got { ftrrec ftridx true } { false } ifelse
	end
} bind def

% ttfdict scptid langid fturid <ttfGetGSUBTable> ttfdict arrayofarray true
%	ttfdict false
/ttfGetGSUBTable {
	ttfFindGSUBTable {
		1 dict begin
		ttfReadFeatureTable	/lutidx exch def pop
		ttfReadGSUBTable
		ttfReadLookupList /lutlst exch def pop
		lutidx length array dup {
			3 index lutlst lutidx 3 index get ttfReadLookupTable
			ttfReadGSUBLookupSubTable
			3 -2 roll pop pop put
		} for-array
		true
		end
	} {
		false
	} ifelse
} bind def

% gid [ [ substdict ... ] ... ] ttfLookupGlyph gid' bool
/ttfLookupGlyph {
	dup type /dicttype eq {
		begin Lookup end
	} {
		{
			ttfLookupGlyph { exit } if
		} forall
	} ifelse
} bind def

% dict substarray <mergeCoverage> dict
/mergeCoverage {
	dup type /dicttype eq {
		begin
		Coverage /CoverageLookup get {
			pop 2 copy known {
				pop
			} {
				dup Lookup
				{ 2 index 3 -2 roll put } { pop pop } ifelse
			} ifelse
		} forall
		end
	} {
		{ mergeCoverage } forall
	} ifelse
} bind def

[ /MS-PGothic /IPAexMincho /DFPKaiSho-Md ] {
	(-----------------------------------------------------------------\n) print
	/CIDFont findresource ttfFindFontTable
	not { /ttf-notfound trap } if
	ttfReadHmtxTable pop
	/vmtx ttfCheckSupport { ttfReadVmtxTable pop } if
	[
		[ /kana (JAN ) /vert ]
		[ /hani (JAN ) /vert ]
	]
	dup length array dup {
		% ttfdict array array' array' index
		4 index 4 index 2 index get aload pop ttfGetGSUBTable
		{
			% ttfdict array array' array' index ttfdict gsub
			exch pop put
		} {
			% ttfdict array array' array' index ttfdict
			pop pop pop
		} ifelse
	} for-array
	exch pop
	1 dict exch mergeCoverage
	{ exch aprint ( -> ) print aprint (\n) print } forall
	ttfCloseFontFile
} forall
/end dstack
[ (dictstack depth: ) countdictstack (\n) ] aprint
quit
