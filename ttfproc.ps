%!

/ttfprocDebug { exec } def
/ttfprocVerbose { pop } def
/ttfprocMoreVerbose { pop } def
/aprintDebug { ttfprocDebug { aprint flush } ttfprocDebug } def
/aprintVerbose { ttfprocVerbose { aprint flush } ttfprocVerbose } def
/aprintMoreVerbose {
	ttfprocMoreVerbose { aprint flush } ttfprocMoreVerbose
} def

/MaxStringBuffer 256 def

% value object key [ vokput ] -
/vokput { 2 index put pop } bind def

% name <loadexec> obj exec
/loadexec {
	load /exec cvx
} bind def

% <dict> <key> knownget ( <val> true ) | false
% knownget has same functionality as .knownget in GS.
/knownget {
	2 copy known { get true } { pop pop false } ifelse
} bind def

% <key> <default> defaultload <value>
/defaultload {
	exch dup where {
		exch get exch pop
	} {
		pop
	} ifelse
} bind def

% proc <protected-exec> -
%	dictionary stack is poped, execute proc,
%	then the dictionary stack is restored.
%	exit will be trapped. if exit is executed in proc, exit is re-executed,
%	and "exited" is set to true, false otherwise.
/protected-exec {
	1 {
		/exited true def
		[ /exec cvx currentdict ] cvx end exec
		/exited false put
	} [ /repeat cvx currentdict ] cvx exec begin
	exited { exit } if
} bind def

% array makeproc proc
%	this procedure cannot leave name as it is,
%	if it is not included in sub-clauses.
/makeproc {
	[ exch { dup type /nametype eq { cvx } if } forall ] cvx
} bind def

% <obj> <proc> exec-forall -
/exec-forall {
	1 index type /arraytype eq {
		forall
	} {
		1 exch repeat
	} ifelse
} bind def

% array proc <for-array> -
%	procspec: array num <proc> -
/for-array {
	1 dict begin
	/p exch def
	/a exch def
	0 1 a length 1 sub {
		a exch /p load protected-exec
	} for
	end
} bind def

% array proc <for-array-rev> -
%	procspec: array num <proc> -
/for-array-rev {
	1 dict begin
	/p exch def
	/a exch def
	a length 1 sub -1 0 {
		a exch /p load protected-exec
	} for
	end
} bind def

% num proc <repeat-count> -
/repeat-count {
	exch 1 sub exch 0 1 4 2 roll for
} bind def

% str <str2num> num
/str2num {
	0 exch { exch 8 bitshift add } forall
} bind def

% num str <num2str> str
/num2str {
	1 dict begin
	/s exch def
	s {
		2 index 255 and put
		-8 bitshift
	} for-array-rev
	pop s end
} bind def

% arrayofstr <concatallstring> str
/concatallstring {
	dup 0 exch { length add } forall
	string exch
	0 exch {
		dup length exch
		3 index exch 3 index exch putinterval
		add
	} forall pop
} bind def

% - [ strbufCreate ] strbuf
/strbufCreate {
	<< /buf () /pos 0 >>
} def

% strbuf <strbufLength> int
/strbufLength {
	/pos get
} bind def

% strbuf len [ strbufRealloc ] -
/strbufRealloc {
	2 dict begin
	/len exch def
	/strbuf exch def
	strbuf /buf get length
	dup len lt {
		2 mul
		dup len lt { pop len } if
		{ (realloc to ) print dup == } pop
		string dup 0 strbuf /buf get putinterval strbuf /buf vokput
	} {
		pop
	} ifelse
	end
} bind def

% strbuf str [ strbufAppend ] -
/strbufAppend {
	1 index begin
	3 dict begin
	/str exch def
	/strbuf exch def
	/newlen pos str length add def
	strbuf newlen strbufRealloc
	buf pos str putinterval
	strbuf /pos newlen put
	end end
} bind def

% strbuf [ strbufGetString ] string
/strbufGetString {
	begin
	buf 0 pos getinterval
	end
} bind def

% str num <splitstring> substrtail substrhead
/splitstring {
	2 dict begin
	/n exch def
	/s exch def
 	s n s length n sub getinterval
	s 0 n getinterval
	end
} bind def

% file num <forward> -
/forward {
	1 index fileposition add setfileposition
} bind def

/aprint-float-digits {
	dup 0.1 mul 0.05 add floor exch % div val
	1 index 10 mul sub round	% div mod
	dup 0 lt { pop (0) } {
	dup 9 gt { pop (9) } {
		cvi 1 string cvs	% default
	} ifelse } ifelse exch
} bind def

/aprint-longval-divmod10 {
	1 dict begin
	/m 0 def
	/f true def
	[ exch {
		m 256 mul add dup 10 idiv exch
		10 mod /m exch def
		dup 0 eq f and { pop } if
		/f false def
	} forall ]
	m
	end
} bind def

% val width <aprint-float-fixed> str
/aprint-float-fixed {
	1 dict begin
	/prec exch def
	/val exch def
	/str strbufCreate def
	/s 1 string def

	% 符号
	val 0 lt {
		str (-) strbufAppend
		/val val abs def
	} if

	% 丸めておく
	/val val 10 prec neg exp 0.5 mul add def

	% 整数部と小数部に分ける
	/ipart val floor def
	/fpart val ipart sub def

	% 整数部を256進表現にする。
	/n 0 def
	{
		ipart 1 lt { exit } if
		/ipart ipart 256 div def
		/n n 8 add def
		n 5000 gt { /aprint-float-overflow trap } if
	} loop
	/ipart [ ipart n 8 idiv {
		256 mul dup floor cvi exch 1 index sub
	} repeat pop ] def

	% 下位桁から10進分解する。
	mark {
		ipart length 0 eq { exit } if
		ipart aprint-longval-divmod10 exch /ipart exch def
	} loop

	% 文字列に直す
	{
		dup mark eq { exit } if
		s cvs str exch strbufAppend
	} loop
	pop

	% 空っぽなら0を追加
	str strbufLength 0 eq { str (0) strbufAppend } if

	% 小数部
	str (.) strbufAppend
	fpart prec {
		10 mul dup floor dup cvi s cvs
		str exch strbufAppend
		sub
	} repeat pop

	str strbufGetString
	end
} bind def

% str align width aprint-align -
/aprint-align {
	2 index length	% str align width len
	sub	% str align width-len
	dup 0 le {
		pop pop print
	} { exch dup /right eq {	% str width-len align
		pop { ( ) print } repeat print
	} { dup /left eq {
		pop exch print { ( ) print } repeat
	} { type /stringtype eq {
		1 index 0 1 getinterval (-) eq {
			(-) print { A print } repeat
			1 1 index length 1 sub getinterval print
		} {
			{ A print } repeat print
		} ifelse
	} {
		/aprint-align trap
	} ifelse } ifelse } ifelse } ifelse
} def

% str <aprint-format-string> str'
/aprint-format-string {
	S /char eq {
		% do nothing.
	} { S /hex eq {
		[ (<)
		2 index {
			16 2 string cvrs
			dup length 2 lt { (0) exch } if
		} forall
		(>) ] concatallstring exch pop
	} {
		/aprint-format-string trap
	} ifelse } ifelse
} bind def

% array <aprint> -
% anyother <aprint> -
/aprint {
	1 dict begin
	/W 0 def	% field width
	/P 6 def	% precision
	/A /right def	% align: /right, /left or string to fill
	/F /fixed def	% floating point format
	/S /char def	% string format, /hex: postscript hexstring
	/R 10 def	% radix
	{ 1 {
		dup type /integertype eq { R 32 string cvrs A W aprint-align exit } if
		dup type /realtype eq { P aprint-float-fixed A W aprint-align exit } if
		dup type /dicttype eq { { def } forall exit } if
		dup type /nametype eq { dup length string cvs } if % fall through
		dup type /stringtype eq {
			aprint-format-string A W aprint-align exit
		} if
		dup type /booleantype eq {
			{ (true) } { (false) } ifelse print exit
		} if
		/aprint trap
	} repeat } exec-forall
	end
} def

/dstack {
	(--- ) print aprint ( ---\n) print
	pstack
	(---------\n) print flush
} bind def

/ddump {
	(=== ) print aprint ( ===\n) print
	dup { exch aprint ( ) print == } forall
	(=========\n) print flush
} bind def

/dval {
	dup aprint (=) print load ==
} bind def

% str <charbytes> num
/charbytesUTF8 {
	0 get
	dup 16#80 lt { 1 } {
	dup 16#c2 lt { /charbytesUTF8 trap } {
	dup 16#e0 lt { 2 } {
	dup 16#f0 lt { 3 } {
	dup 16#f8 lt { 4 } {
		/charbytesUTF8 trap	% default
	} ifelse } ifelse } ifelse } ifelse } ifelse
	exch pop
} bind def

/charbytesUCS2 {
	pop 2
} bind def

/charbytesUTF16BE {
	0 get
	dup 16#d8 lt { 2 } {
	dup 16#dc lt { 4 } {
	dup 16#e0 lt { /charbytesUTF16 trap } {
		2	% default
	} ifelse } ifelse } ifelse
} bind def

/charbytesUTF32 {
	pop 4
} bind def

% num <checkUnicode> num
/checkUnicode {
	dup 16#d800 lt { } {
	dup 16#e000 lt { /checkUnicode trap } {
	dup 16#110000 lt { } {
		/checkUnicode trap % default
	} ifelse } ifelse } ifelse
} bind def

% str <decode> num

/decodeUTF8Mask [ 16#ff 16#1f 16#0f 16#07 ] def
/decodeUTF8Limit [ 0 16#80 16#800 16#10000 ] def

% str <decodeUTF8> substrtail num
/decodeUTF8 {
	2 dict begin
	/s exch def
	s charbytesUTF8
	s 1 index splitstring pop exch
	1 sub /taillen exch def
	s 0 get //decodeUTF8Mask taillen get and
	s 1 taillen getinterval
	{
		dup 16#80 lt { /decodeUTF8b trap } if
		dup 16#c0 ge { /decodeUTF8c trap } if
		16#3f and exch 6 bitshift add
	} forall
	checkUnicode
	dup //decodeUTF8Limit taillen get lt { /decodeutf8d trap } if
	end
} bind def

currentdict /decodeUTF8Mask undef
currentdict /decodeUTF8Limit undef

% num <encodeUTF8> str
/encodeUTF8 {
	1 dict begin
	/u exch def
	u 16#80 lt {
		1 string dup 0 u put
	} {
		u 16#800 lt { 2 16#c0 } {
		u 16#10000 lt { 3 16#e0 } {
		u 16#110000 lt { 4 16#f0 } {
			/encodeUTF8 trap	% default
		} ifelse } ifelse } ifelse
		/msb exch def
		dup string exch
		1 sub -6 mul /bs exch def
		dup {
			u bs bitshift 16#3f and msb or put
			/msb 16#80 def
			/bs bs 6 add def
		} for-array
	} ifelse
	end
} bind def

% str <_decodeUCS2> num
/_decodeUCS2 {
	dup 1 get exch 0 get 8 bitshift add
} bind def

% str <decodeUCS2> substrtail num
/decodeUCS2 {
	2 splitstring
	_decodeUCS2
	checkUnicode
} bind def 

% str num <_encodeUCS2> str
/_encodeUCS2 {
	1 index 0 2 index -8 bitshift put
	1 index exch 1 exch 16#ff and put
} bind def

% num <encodeUCS2> str
/encodeUCS2 {
	checkUnicode
	dup 16#10000 ge { /encodeUCS2 trap } if
	2 string exch _encodeUCS2
} bind def

% str <decodeUTF16> substrtail num
/decodeUTF16 {
	2 splitstring _decodeUCS2
	dup 16#dc00 ge 1 index 16#e000 lt and { /decodeUTF16a trap } if
	dup 16#d800 ge 1 index 16#dc00 lt and {
		exch 2 splitstring _decodeUCS2	% hi substr lo
		dup 16#dc00 lt 1 index 16#e000 ge or { /decodeUTF16b trap } if
		3 -1 roll	% substr lo hi
		16#3ff and 10 bitshift exch 16#3ff and add 16#10000 add
	} if
	checkUnicode
} bind def

% num <encodeUTF16> str
/encodeUTF16 {
	checkUnicode
	dup 16#10000 lt {
		2 string exch _encodeUCS2
	} {
		16#10000 sub
		4 string exch
		dup 16#3ff and 16#dc00 add exch
		-10 bitshift 16#d800 add
		2 index 0 2 getinterval exch _encodeUCS2 pop
		1 index 2 2 getinterval exch _encodeUCS2 pop
	} ifelse
} bind def

% str <decodeUTF32> num
/decodeUTF32 {
	4 splitstring 0 exch {
		exch 8 bitshift add
	} forall
	checkUnicode
} bind def

% num <encodeUTF32> num
/encodeUTF32 {
	checkUnicode
	4 string exch 1 index {
		3 exch sub
		2 index 16#ff and put
		-8 bitshift
	} for-array
	pop
} bind def

% str dec-encproc <convertstring> str'
%	dec-encproc: str <dec-encproc> substrtail strchar
/convertstring {
	1 dict begin
	/decenc exch def
	[ exch {
		dup length 0 eq { exit } if
		/decenc load protected-exec exch
	} loop pop ]
	concatallstring
	end
} bind def

% strarray pos size <getstrarray> substr true
% strarray pos size <getstrarray> false
/getstrarray {
	4 dict begin
	/sz exch def
	sz mul /pos exch def
	/got false def
	{
		/s exch def
		pos s length lt {
			s pos sz getinterval
			/got true def
			exit
		} if
		/pos pos s length sub def
	} exec-forall
	got
	end
} bind def

% proc <moreverbose> -
/moreverbose {
	1 dict begin
	/CurrentVerbose /ttfprocVerbose load def
	/ttfprocVerbose /ttfprocMoreVerbose load store
	protected-exec
	/ttfprocVerbose /CurrentVerbose load store
	end
} bind def

% file num <bindfilebuffer> obj
/bindfilebuffer {
	[ 3 1 roll string /readstring /not { /readstring trap } /if ] makeproc
} bind def

1 dict begin % ttfprocUtility

/b2 /FontFile 2 bindfilebuffer def
/b4 /FontFile 4 bindfilebuffer def
/n2 { b2 str2num } bind def
/n4 { b4 str2num } bind def
/off2 { n2 Offset add } bind def
/off4 { n4 Offset add } bind def
/setpos { FontFile exch setfileposition } bind def
/fwd { FontFile fileposition add setpos } bind def

/ckver {
	/Version b4 def
	{ ( ver=) print Version ttfPrintVersion } ttfprocDebug
	Version gt { /ttfver trap } if
} bind def

/ckdup {
	currentdict 1 index known { /ttf-duptag trap } if
} bind def

% obj key proc <retr> dict
% retrieve standard table
/retr {
	1 dict begin
	/p exch def
	/k exch def
	/o exch def
	o k get dup type /dicttype ne {
		1 dict begin
		o k currentdict put
		/Offset exch def
		true
	} { dup /Retrieved known not {
		begin true
	} {
		false
	} ifelse } ifelse
	{
		/Key k def
		[ Key (: off=) Offset ] aprintDebug
		Offset setpos p
		/Retrieved true def
		(\n) aprintDebug
		currentdict end
	} {
		[ k (: (cached)\n) ] aprintDebug
	} ifelse
	end
} bind def

% name num <idxtbl> -
/idxtbl {
	array exch 1 index def
	{
		n2 [ ( ) 2 index ] aprintVerbose put
	} for-array
} bind def

% name num <offtbl> -
/offtbl {
	array exch 1 index def
	{
		off2 [ ( ) 2 index ] aprintVerbose put
	} for-array
} bind def

% num <tagoff> -
/tagoff {
	{
		b4 cvn [ (\n  ) 2 index ] aprintVerbose ckdup
		off2 [ (: off=) 2 index ] aprintVerbose def
	} repeat
} bind def

currentdict end
/ttfprocUtility exch def

% file <ttfReadTTCHeader> otfdict
/ttfReadTTCHeader {
	//ttfprocUtility begin
	1 dict begin
	/FontFile exch def
	b4 (ttcf) eq {
		(TrueType Collection: ) aprintDebug
		<00010000> ckver
		/NumFonts n4 def
		[ ( numfonts=) NumFonts ] aprintDebug
		[ (\n  offsets:) ] aprintVerbose
		/OffsetTable [ NumFonts {
			n4 [ ( ) 2 index ] aprintVerbose
		} repeat ] def
	} {
		(TrueType single font (maybe)) aprintDebug
		/Version <00010000> def
		/NumFonts 1 def
		/OffsetTable [ 0 ] def
	} ifelse
	(\n) aprintDebug
	currentdict end end
} bind def

% str <ttfPrintVersion> -
/ttfPrintVersion {
	str2num [
		1 index -16 bitshift (.)
		<< /R 16 /W 4 /A (0) >> 4 index 16#ffff and
	] aprint
	pop
} bind def

% otfdict subfontnum <ttfReadTrueTypeHeader> ttfdict
/ttfReadTrueTypeHeader {
	1 index begin
	//ttfprocUtility begin
	1 dict begin
	/sf exch def
	/otf exch def
	(TrueType Offset Table ) aprintDebug
	OffsetTable sf {
		% copy utility procedures
		//ttfprocUtility currentdict copy
		/FontFile FontFile def
		<00010000> ckver
		/NumTables n2 def
		[ ( cnt=) NumTables ] aprintDebug
		6 fwd
		/OffsetTable NumTables dict def
		OffsetTable begin NumTables {
			b4 cvn [ (\n  ) 2 index ] aprintVerbose ckdup
			<<
				/Checksum n4
				[ (: sum=) << /R 16 /W 8 /A (0) >> 3 index ] aprintVerbose
				/Offset n4 [ ( off=) 2 index ] aprintVerbose
				/Length n4 [ ( len=) 2 index ] aprintVerbose
			>> def
		} repeat end
	} retr
	end end end exch pop
} bind def

% otfdict | ttfdict <ttfCloseFontFile> -
/ttfCloseFontFile {
	begin
	FontFile type /filetype eq {
		(ttfCloseFontFile: closing file\n) aprintDebug
		FontFile closefile
		/FontFile null def
	} if
	end
} bind def

% ttfdict <ttfReadNameTable> ttfdict namedict
/ttfReadNameTable {
	dup begin
	OffsetTable /name {
		/Format n2 def
		[ ( format=) Format ] aprintDebug
		Format 0 eq {
			/Count n2 def
			[ ( cnt=) Count ] aprintDebug
			/StringOffset off2 def
			[ ( stroff=) StringOffset ] aprintDebug
			/NameRecord Count array def
			NameRecord {
				[ (\n  ) 2 index (:) ] aprintVerbose
				<<
				/PlatformID n2
				[ ( platform=) 2 index ] aprintVerbose
				/EncodingID n2
				[ ( enc=) 2 index ] aprintVerbose
				/LanguageID n2
				[ ( lang=) 2 index ] aprintVerbose
				/NameID n2
				[ ( nameid=) 2 index ] aprintVerbose
				/Length n2
				[ ( len=) 2 index ] aprintVerbose
				/String n2 StringOffset add
				[ ( off=) 2 index ] aprintVerbose
				>> put
			} for-array
		} {
			/ttfnamefmt0 trap
		} ifelse
	} retr
	end
} bind def

% decode table for platform ID 3
/ttfNameDecodePF3 <<
	1 { decodeUCS2 }
	10 { decodeUCS4 }
>> def

/ttfNameDecode <<
	3 ttfNameDecodePF3
>> def

% dict <ttfGetDecodeTable> ( decodeproc true | false )
%	using PlatformID and EncodingID in dict.
/ttfGetDecodeTable {
	begin
	//ttfNameDecode PlatformID knownget dup { pop EncodingID knownget } if
	end
} bind def

% ttfdict <ttfGetFontName> ttfdict str
/ttfGetFontName {
	dup begin
	1 dict begin
	/got false def

	ttfReadNameTable	% ttfdict namedict
	/NameRecord get {
		dup /NameID get 6 eq {
			dup ttfGetDecodeTable { /got true def exit } if
		} if
		pop
	} forall
	got not { /ttfrdfn0 trap } if
	/decproc exch def

	begin
	String dup type /integertype eq {
		[ (  fontname: off=) 2 index ] aprintDebug
		setpos
		FontFile Length string readstring not { /ttfdfn1 trap } if
		[ /decproc loadexec /encodeUTF8 loadexec ] cvx convertstring
		dup /String exch def
		[ ( string=) String (\n) ] aprintDebug
	} if
	end end end
} bind def

% font <ttfFindFontTable> (ttfdict true) | false
/ttfFindFontTable {
	1 dict begin
	dup /CIDFontName get /FontNickName exch def
	/FontName get /FontRealName exch def
	[ (ttfFindFontTable: FontName=) FontRealName ] aprintDebug
	[ ( CIDFontName=) FontNickName (\n) ] aprintDebug
	/got false def
	/CIDFont /Category findresource begin
	FontNickName MaxStringBuffer string ResourceFileName
	end
	[ (  filename=) 2 index (\n) ] aprintDebug
	(r) file ttfReadTTCHeader /otf exch def
	otf /NumFonts get {	% otf subfontid
		otf exch ttfReadTrueTypeHeader	% ttfdict
		ttfGetFontName	% ttfdict str
		dup FontRealName eq { pop /got true def exit } if	% ttfdict str
		FontNickName eq { /got true def exit } if	% ttfdict
		pop
	} repeat-count	% ttfdict |
	got { true } { otf ttfCloseFontFile false } ifelse
	end
} bind def

% ttfdict id <ttfCheckSupport> ttfdict bool
/ttfCheckSupport {
	1 index /OffsetTable get exch known
} bind def

% ttfdict <ttfRead-head> ttfdict
% 	head table specific informations are stored in head dict.
%	global informations are stored in ttfdict directly.
/ttfReadHeadTable {
	dup begin
	OffsetTable /head {
		<00010000> ckver
		dup begin
			14 fwd /UnitsPerEm n2 def
			[ ( funit=) UnitsPerEm ] aprintDebug
		end
	} retr pop
	end
} bind def

% ttfdict <ttfReadMaxpTable> ttfdict
% 	maxp table specific informations are stored in maxp dict.
%	global informations are stored in ttfdict directly.
/ttfReadMaxpTable {
	dup begin
	OffsetTable /maxp {
		<00005000> ckver
		dup begin
			/NumGlyphs n2 def
			[ ( numglyphs=) NumGlyphs ] aprintDebug
		end
	} retr pop
	end
} bind def

% ttfdict <ttfReadOS2Table> ttfdict
/ttfReadOS2Table {
	ttfReadHeadTable
	dup begin
	OffsetTable (OS/2) cvn {
		68 fwd
		dup begin
			/TypoAscender n2 UnitsPerEm div def
			[ ( typoasnd=) TypoAscender ] aprintDebug
		end
	} retr pop
	end
} bind def

{ %========== these are unused ==========

% ttf <ttfReadCmapTable> ttf cmapdict
/ttfReadCmapTable {
	dup begin
	OffsetTable /cmap {
		/Version n2 def
		[ ( ver=) Version ] aprintDebug
		/NumTables n2 def
		[ ( cnt=) NumTables ] aprintDebug
		/Encoding NumTables array def
		Encoding {
			<<
			/PlatformID n2 [ (\n  pf=) 2 index ] aprintDebug
			/EncodingID n2 [ ( enc=) 2 index ] aprintDebug
			/Offset off4 [ ( off=) 2 index ] aprintDebug
			>> put
		} for-array
	} retr
	end
} bind def

% ttf pf enc <ttfCheckCmapTable> ttf ( cmaparray idx true ) | false
/ttfCheckCmapTable {
	1 dict begin
	/enc exch def
	/pf exch def
	/got false def
	ttfReadCmapTable /Encoding get {
		2 copy get begin
		PlatformID pf eq EncodingID enc eq and
		end
		{ /got true def exit } if
		pop pop
	} for-array
	got
	end
} bind def

% ttf <ttfReadCmapSubtableFormat12> ttf
%	 use currentdict as cmapdict.
/ttfReadCmapSubtableFormat12 {
	10 fwd
	/NumGroups n4 def
	[ ( cnt=) NumGroups ] aprintDebug
	1 dict begin
	NumGroups {
		n4 [ (\n  0x) << /A (0) /W 5 /R 16 >> 3 index ] aprintVerbose
		n4 [ ( ... 0x) << /A (0) /W 5 /R 16 >> 3 index ] aprintVerbose
		n4 [ ( -> ) 2 index ] aprintVerbose
		2 index 1 3 index {
			[ (\n    0x) << /A (0) /W 5 /R 16 >> 3 index ] aprintMoreVerbose
			1 index [ ( -> ) 2 index ] aprintMoreVerbose
			def
			1 add
		} for
		pop pop pop
	} repeat
	currentdict end /CharToGlyphMap exch def
} bind def

% ttf cmaparray idx <ttfReadCmapSubtable> ttf cmapdict
/ttfReadCmapSubtable {
	2 index begin
	(cmap subtable ) aprintDebug
	{
		/Format n2 def
		[ ( fmt=) Format ] aprintDebug
		1 {
			Format 12 eq {
				ttfReadCmapSubtableFormat12
				exit
			} if
			/ttf-cmap-format trap
		} repeat
	} retr
	end
	quit
} bind def

} pop %========== end of unused portion ==========

% ttfdict <ttfReadHheaTable> ttfdict hheadict
/ttfReadHheaTable {
	dup begin
	OffsetTable /hhea {
		<00010000> ckver
		28 fwd
		/MetricDataFormat n2 def
		[ ( format=) MetricDataFormat ] aprintDebug
		/NumberOfMetrics n2 def
		[ ( numhmtx=) NumberOfMetrics ] aprintDebug
	} retr
	end
} bind def

% ttfdict ( hheadict | vheadict ) id <ttfReadMetricsTable> ttfdict mtxdict
%	metrics values are normalized.
/ttfReadMetricsTable {
	2 index begin
	1 dict begin
	/id exch def
	/xhea exch def
	xhea /MetricDataFormat get 0 ne { /mtx-format trap } if
	ttfReadHeadTable
	ttfReadMaxpTable
	OffsetTable id {
		/AdvanceDistance xhea /NumberOfMetrics get array def
		[ (\n  values:) ] aprintMoreVerbose
		AdvanceDistance {
			n2 UnitsPerEm div
			[ ( ) 2 index ] aprintMoreVerbose put
			2 fwd
		} for-array
	} retr
	end end
} bind def

% ttfdict <ttfReadHmtxTable> ttfdict hmtxdict
/ttfReadHmtxTable {
	ttfReadHheaTable
	/hmtx ttfReadMetricsTable
} bind def

% ttfdict <ttfReadVheaTable> ttfdict vheaddict
/ttfReadVheaTable {
	dup begin
	OffsetTable /vhea {
		<00010000> ckver
		28 fwd
		/MetricDataFormat n2 def
		[ ( format=) MetricDataFormat ] aprintDebug
		/NumberOfMetrics n2 def
		[ ( numvmtx=) NumberOfMetrics ] aprintDebug
	} retr
	end
} bind def

% ttfdict <ttfReadVmtxTable> ttfdict vmtxdict
/ttfReadVmtxTable {
	ttfReadVheaTable
	/vmtx ttfReadMetricsTable
} bind def

% ttfdict comdict id <ttfReadScriptList> ttfdict scrldict
/ttfReadScriptList {
	1 index begin
	/ScriptList {
		/ScriptCount n2 def
		[ ( cnt=) ScriptCount ] aprintDebug
		ScriptCount tagoff
	} retr
	end
} bind def

% ttfdict scrldict scriptid <ttfReadScriptTable> ttfdict scrtdict
/ttfReadScriptTable {
	2 index begin
	{
		/DefaultLangSys n2 dup 0 ne {
			Offset add dup /default exch def
		} if def
		[ ( deflang=) DefaultLangSys ] aprintDebug
		/LangSysCount n2 def
		[ ( cnt=) LangSysCount ] aprintDebug
		LangSysCount tagoff
	} retr
	end
} bind def

% ttfdict scrtdict langid <ttfReadLangSysTable> ttfdict langdict
/ttfReadLangSysTable {
	2 index begin
	(LangSysTable ) aprintDebug
	{
		n2 0 ne { /ttflangsys-luorder trap } if
		/ReqFeatureIndex n2 def
		[ ( reqidx=) ReqFeatureIndex ] aprintDebug
		/FeatureCount n2 def
		[ ( cnt=) FeatureCount ] aprintDebug
		(\n  fturidx:) aprintVerbose
		/FeatureIndex FeatureCount idxtbl
	} retr
	end
} bind def

% ttfdict comdict <ttfReadFeatureList> ttfdict ftrldict ftrrec
/ttfReadFeatureList {
	1 index begin
	/FeatureList {
		/FeatureCount n2 def
		[ ( cnt=) FeatureCount ] aprintDebug
		/FeatureRecord FeatureCount array def
		FeatureRecord {
			[ (\n  ) 2 index (:) ] aprintVerbose
			<< /Tag b4 cvn [ ( tag=) 2 index ] aprintVerbose
			/Offset off2 [ ( off=) 2 index ] aprintVerbose >> put
		} for-array
	} retr
	dup /FeatureRecord get
	end
} bind def

% ttfdict ftrrec idx <ttfReadFeatureTable> ttfdict ftrtdict luidxarray
/ttfReadFeatureTable {
	2 index begin
	(FeatureTable ) aprintDebug
	{
		/FeatureParams n2 def
		[ ( params=) FeatureParams ] aprintDebug
		FeatureParams 0 ne { /ttfftrt-params trap } if
		/LookupCount n2 def
		[ ( cnt=) LookupCount ] aprintDebug
		[ (\n  luplidx:) ] aprintVerbose
		/LookupListIndex LookupCount idxtbl
	} retr
	dup /LookupListIndex get
	end
} bind def

% ttfdict comdict <ttfReadLookupList> ttfdict lupldict luarray
/ttfReadLookupList {
	1 index begin
	/LookupList {
		/LookupCount n2 def
		[ ( cnt=) LookupCount ] aprintDebug
		(\n  offsets:) aprintVerbose
		/Lookup LookupCount offtbl
	} retr
	dup /Lookup get
	end
} bind def

% ttfdict luarray luidx <ttfReadLookupTable> ttfdict lutdict
/ttfReadLookupTable {
	2 index begin
	(LookupTable ) aprintDebug
	{
		/LookupType n2 def
		[ ( type=) LookupType ] aprintDebug
		/LookupFlag n2 def
		[ ( flag=) LookupFlag ] aprintDebug
		/SubTableCount n2 def
		[ ( cnt=) SubTableCount ] aprintDebug
		(\n  offsets:) aprintVerbose
		/SubTable SubTableCount offtbl
		LookupFlag 16#10 and 0 ne {
			/MarkFilteringSet n2 def
			[ (\n  filt=) MarkFilteringSet ] aprintDebug
		} if
	} retr
	end
} bind def

% ttf lsubdict covid <ttfReadCoverageTable> ttf lsubdict covdict
/ttfReadCoverageTable {
	2 index begin
	1 index exch
	{
		/CoverageFormat n2 def
		[ ( fmt=) CoverageFormat ] aprintDebug
		CoverageFormat 1 eq {
			/GlyphCount n2 def
			[ ( cnt=) GlyphCount ] aprintDebug
			(\n  cov:) aprintMoreVerbose
			/GlyphArray GlyphCount { idxtbl } moreverbose
			% create inverse table
			/CoverageLookup << GlyphArray {
				exch 1 index get exch
			} for-array >> def
		} { CoverageFormat 2 eq {
			/RangeCount n2 def
			[ ( cnt=) RangeCount ] aprintDebug
			/CoverageLookup << RangeCount {
				/Start n2 def
				[ (\n  cov: start=) Start ] aprintVerbose
				/End n2 def
				[ ( end=) End ] aprintVerbose
				/StartCoverageIndex n2 def
				[ ( idx=) StartCoverageIndex ] aprintVerbose
				(\n    ->) aprintMoreVerbose
				Start 1 End {
					dup StartCoverageIndex add Start sub
					[ ( ) 3 index ] aprintMoreVerbose
				} for
			} repeat >> def
		} {
			/ttfcov-fmt1 trap
		} ifelse } ifelse
	} retr
	end
} bind def

% ttfdict <ttfReadGSUBTable> ttfdict gsubdict
/ttfReadGSUBTable {
	dup begin
	OffsetTable /GSUB {
		<00010000> ckver
		/ScriptList off2 def
		[ ( script=) ScriptList ] aprintDebug
		/FeatureList off2 def
		[ ( feature=) FeatureList ] aprintDebug
		/LookupList off2 def
		[ ( lookup=) LookupList ] aprintDebug
	} retr
	end
} bind def

% substdict begin gid <ttfGSUBType1Subst*Lookup> gid' bool
/ttfGSUBType1Subst1Lookup {
	Coverage begin
	CoverageLookup 1 index known {
		DeltaGlyphID add 16#ffff and
		true
	} {
		false
	} ifelse
	end
} bind def

/ttfGSUBType1Subst2Lookup {
	Coverage begin
	CoverageLookup 1 index known {
		CoverageLookup exch get
		Substitute exch get
		true
	} {
		false
	} ifelse
	end
} bind def

% ttf subtblarray subtblidx <ttfReadGSUBLookupSubTable> ttf substdict
/ttfReadGSUBLookupType1SubTable {
	2 index begin
	(GSUB LookupType 1 SubTable ) aprintDebug
	{
		/SubstFormat n2 def
		[ ( fmt=) SubstFormat ] aprintDebug
		SubstFormat 1 eq {
			/Coverage off2 def
			[ ( cov=) Coverage ] aprintDebug
			/DeltaGlyphID n2 def
			[ ( delta=) DeltaGlyphID ] aprintDebug
			/Lookup /ttfGSUBType1Subst1Lookup load def
		} { SubstFormat 2 eq {
			/Coverage off2 def
			[ ( cov=) Coverage ] aprintDebug
			/GlyphCount n2 def
			[ ( cnt=) GlyphCount ] aprintDebug
			(\n  gids for substitute:) aprintMoreVerbose
			/Substitute GlyphCount { idxtbl } moreverbose
			/Lookup /ttfGSUBType1Subst2Lookup load def
		} {
			/ttf-gsub-subtbl trap
		} ifelse } ifelse
	} retr
	% read coverage
	/Coverage ttfReadCoverageTable pop
	end
} bind def

% ttf lutdict <ttfReadGSUBLookupSubTable> ttf lutdict substarray
/ttfReadGSUBLookupSubTable {
	1 index begin
	dup begin
	LookupType 1 eq {
		SubTable length array dup {
			% ttf lutdict aray array index
			4 index SubTable 2 index ttfReadGSUBLookupType1SubTable
			exch pop put
		} for-array
	} {
		/ttf-gsub-lookuptype trap
	} ifelse
	end end
} bind def

% ttfdict scriptid langid featureid <ttfFindGSUBTable>
%	ttfdict ftrrec ftridx true
%	ttfdict false
/ttfFindGSUBTable {
	3 dict begin
	/feature exch def
	/lang exch def
	/script exch def
	/ttf 1 index def
	/got false def
	1 {
		/GSUB ttfCheckSupport not { (no GSUB table\n) aprintVerbose exit } if
		ttfReadGSUBTable /gsub exch def
		gsub ttfReadScriptList /scrlst exch def
		gsub ttfReadFeatureList /ftrrec exch def pop
		scrlst script known not {
			[ (no ) script (Script\n) ] aprintVerbose exit
		} if
		scrlst script ttfReadScriptTable /scrtbl exch def
		[ lang /default ] {
			/id exch def
			scrtbl id known {
				scrtbl id ttfReadLangSysTable
				(Enumerate FeatureIndex:) aprintVerbose
				/FeatureIndex get {
					[ (\n  fidx=) 2 index ] aprintVerbose
					ftrrec 1 index get /Tag get
					[ ( tag=) 2 index ] aprintVerbose
					feature eq {
						/ftridx exch def
						/got true def
						(, found\n) aprintVerbose
						exit
					} if
					pop
				} forall
			} {
				[ (LangSysTable ) id ( is not found.\n) ] aprintVerbose
			} ifelse
			got { exit } if
		} forall
		got { exit } if
	} repeat
	got { ftrrec ftridx true } { false } ifelse
	end
} bind def

% ttfdict scptid langid fturid <ttfGetGSUBTable> ttfdict arrayofarray true
%	ttfdict false
/ttfGetGSUBTable {
	ttfFindGSUBTable {
		1 dict begin
		ttfReadFeatureTable	/lutidx exch def pop
		ttfReadGSUBTable
		ttfReadLookupList /lutlst exch def pop
		lutidx length array dup {
			3 index lutlst lutidx 3 index get ttfReadLookupTable
			ttfReadGSUBLookupSubTable
			3 -2 roll pop pop put
		} for-array
		true
		end
	} {
		false
	} ifelse
} bind def

% gid [ [ substdict ... ] ... ] ttfLookupGlyph gid' bool
/ttfLookupGlyph {
	dup type /dicttype eq {
		begin Lookup end
	} {
		{
			ttfLookupGlyph { exit } if
		} forall
	} ifelse
} bind def

% dict substarray <ttfMergeCoverage> dict
/ttfMergeCoverage {
	dup type /dicttype eq {
		begin
		Coverage /CoverageLookup get {
			pop 2 copy known {
				pop
			} {
				dup Lookup
				{ 2 index 3 -2 roll put } { pop pop } ifelse
			} ifelse
		} forall
		end
	} {
		{ ttfMergeCoverage } forall
	} ifelse
} bind def

%---------------------------------------------------------------------
% CMap Utilityes
%---------------------------------------------------------------------

% - <ttfDefineCIDInitProcSet> procsetdict
/ttfDefineCIDInitProcSet {

currentglobal
false setglobal

1 dict begin	% CIDInitProcSet

/CMapList 1 dict def

/begincmap {
	(begincmap\n) aprintDebug
	/CodeMap 5 dict def
	CodeMap begin
	/ForwardCMap 1 dict def
	/ReverseCMap 1 dict def
	/BaseCMaps [ ] def
	end
} bind def

/usecmap [ CMapList {
	1 dict begin
		/cmaplist exch def
		/BaseCMapName exch def
		[ (usecmap: cmapname=) BaseCMapName ] aprintDebug
		/CMap /Category findresource begin
			BaseCMapName 256 string ResourceFileName
		end
		[ ( filename=) 2 index (\n) ] aprintVerbose
		(r) file /File exch def
		File cvx protected-exec
		File closefile
		CodeMap begin
			[ cmaplist BaseCMapName get BaseCMaps aload pop ]
			/BaseCMaps exch def
		end
	end
} /exec cvx ] cvx bind def

/begincodespacerange {
	(begincodespacerange ... ) aprintVerbose
	mark
} bind def

/endcodespacerange {
	(endcodespacerange\n) aprintVerbose
	cleartomark pop
} bind def

/beginnotdefrange {
	(beginnotdefrange ... ) aprintVerbose
	mark
} bind def

/endnotdefrange {
	(endnotdefrange\n) aprintVerbose
	cleartomark pop
} bind def

/begincidchar {
	(begincidchar ... ) aprintDebug
	/cidchar mark
} bind def

/append2dict{
	2 index 2 index known {
		2 index 2 index get
		[ exch dup type /arraytype eq {
			aload pop
		} if
		counttomark 1 add index ]
		exch pop put
	} {
		put
	} ifelse
} bind def

/endcidchar {
	(endcidchar\n) aprintDebug
	CodeMap begin
	] exch /cidchar ne { /endcidchar-notbegin trap } if
	1 index 2 mul 1 index length ne { /endcidchar-length trap } if
	exch {
		1 index exch 2 mul 2 getinterval aload pop
		ForwardCMap
			2 index [ (  ) << /S /hex >> 3 index ] aprintVerbose
			2 index [ ( -> ) 2 index (\n) ] aprintVerbose
			append2dict
		ReverseCMap exch 2 index append2dict pop
	} repeat-count
	pop
	end
} bind def

/begincidrange {
	/cidrange (begincidrange ... ) aprintDebug
	mark
} bind def

/endcidrange {
	CodeMap begin
	(endcidrange\n) aprintDebug
	] exch /cidrange ne { /endcidrange-notbegin trap } if
	1 index 3 mul 1 index length ne { /endcidrange-length trap } if
	exch {
		1 index exch 3 mul 3 getinterval
		[ (  ) << /S /hex >> 3 index 0 get << /S /char >> ( ... )
			<< /S /hex >> 7 index 1 get << /S /char >> ( -> )
			10 index 2 get (\n) ] aprintVerbose
		dup 0 get length 1 index 2 get
		2 index 0 get str2num 1 4 index 1 get str2num {
			2 index string num2str
			ForwardCMap
				1 index [ (    ) << /S /hex >> 3 index ] aprintMoreVerbose
				3 index [ ( -> ) 2 index (\n) ] aprintMoreVerbose
				put
			ReverseCMap 2 index 2 index append2dict
			% workaround for GS
			3 index 1 get eq { exit } if
			1 add
		} for
		pop pop pop
	} repeat-count
	pop
	end
} bind def

/endcmap {
	(endcmap\n) aprintDebug
} bind def

% key inst cat <defineresource> inst
/defineresource [ CMapList {
	[ (defineresource: cat=) 3 index ( name=) 7 index (\n) ] aprintDebug
	exch /CMap ne { /defrsc0 trap } if
	3 -1 roll 2 index put
} /exec cvx ] cvx bind def

currentdict end	% CIDInitProcSet
/CIDInit exch /ProcSet defineresource

exch setglobal

} bind def	% ttfDefineCIDInitProcSet

/ttfUndefineCIDInitProcSet {
	currentglobal
	false setglobal
	/CIDInit /ProcSet undefineresource
	setglobal
} bind def

% dict copyfont dict'
/copyfont {
	dup length dict copy
	dup /FID undef
	dup /UIDBase undef
	dup /UniqueID undef
	begin
	/XUID [ 1000000 XUID aload pop ] def
	currentdict end
} bind def

% cidmap copyCIDMap cidmap'
% currentdict is used as font.
/copyCIDMap {
	dup type /arraytype eq {
		[ exch { dup length string copy } forall ]
	} {
		dup length string copy
	} ifelse
} bind def

% cmap cid <ttfCheckReverseCMap> bool
/ttfCheckReverseCMap {
	2 dict begin
	/cid exch def
	/CodeMap get /codemap exch def
	codemap /ReverseCMap get cid known {
		true
	} {
		false codemap /BaseCMaps get {
			cid ttfCheckReverseCMap { pop true exit } if
		} forall
	} ifelse
	end
} bind def

% cmap str <ttfLookupForwardCMap> ( cid true | false )
/ttfLookupForwardCMap {
	2 dict begin
	/str exch def
	/CodeMap get /codemap exch def
	codemap /ForwardCMap get dup str known {
		str get true
	} {
		pop
		false codemap /BaseCMaps get {
			str ttfCheckReverseCMap { exch pop true exit } if
		} forall
	} ifelse
	end
} bind def

% ttf featuretable <ttfGetGSUBSubstDict> dict
/ttfGetGSUBSubstDict {
	1 dict begin
	/features exch def
	/ttfdict exch def
	[ ttfdict features {
		aload pop ttfGetGSUBTable {
			exch
		} if
	} forall pop ]
	1 dict exch ttfMergeCoverage
	{
		dup { exch aprint ( -> ) print aprint (\n) print } forall
	} ttfprocMoreVerbose
	end
} bind def

% font cmap <ttfVerticalFixupCIDFont> font'
/ttfVerticalFixupCIDFont {
	1 dict begin

	dup type /dicttype eq { /CMapName get } if
	/cmapname exch def
	dup type /dicttype ne {
		/fontname exch def
		fontname /CIDFont findresource
	} {
		dup /CIDFontName get /fontname exch def
	} ifelse
	/cidfont exch def

	currentglobal
	false setglobal

	cidfont ttfFindFontTable not { /ttf-notfound trap } if
	/ttfdict exch def
	ttfdict [
		[ /kana (JAN ) /vert ]
		[ /hani (JAN ) /vert ]
	] ttfGetGSUBSubstDict
	/vertsubst exch def

	/CMap /Category findresource
	begin cmapname 256 string ResourceFileName end
	[ (getting filename for ) cmapname (: ) 4 index (\n) ] aprintDebug
	(r) file dup cvx
	/cmaplist ttfDefineCIDInitProcSet /CMapList get def
	exec closefile

	cidfont copyfont begin
	currentdict /subst_CID_on_WMode undef
	/FontType 42 def
	/DEVICE /defaultdevice defaultload /pdfwrite ne {
		/CIDSystemInfo <<
			/Registry (Artifex)
			/Ordering (Identity)
			/Supplement 0
		>> readonly def
	} if

	(Fixup CIDMap for vertical writing mode ... ) aprintDebug
	/CIDMap CIDMap copyCIDMap def

	1 dict begin	% vertical-subst
	/vcodemap cmaplist cmapname get /CodeMap get def
	1 {
		/basecmap vcodemap /BaseCMaps get def
		basecmap length 1 gt {
			/ttfvert-toomanybasecmaps trap
		} if
		basecmap length 1 ne {
			(no base cmap) aprintDebug exit
		} if
		/hcmap basecmap 0 get def

		/replace 1 dict def
		vcodemap /ForwardCMap get {
			/vcid exch def
			/mapchar exch def
			[ (\n  ) << /S /hex >> mapchar ] aprintVerbose
			[ << /W 5 >> vcid ] aprintVerbose
			1 {
				hcmap mapchar ttfLookupForwardCMap not {
					(no horizchar) aprintVerbose exit
				} if
				/hcid exch def
				[ (: hcid=) << /W 6 /A /left >> hcid ] aprintVerbose

				CIDMap hcid GDBytes getstrarray not {
					(no glyph) aprintVerbose exit
				} if
				str2num /hgid exch def
				[ (hgid=) << /W 6 /A /left >> hgid ] aprintVerbose

				vertsubst hgid known not {
					(no subst) aprintVerbose exit
				} if
				/vgid vertsubst hgid get def
				[ (vgid=) << /W 6 /A /left >> vgid ] aprintVerbose

				% vgid may become source of vertsubst or not?
				vertsubst vgid known {
					(shared) aprintVerbose exit
				} if

				CIDMap vcid GDBytes getstrarray not {
					(no gid in cidmap) aprintVerbose exit
				} if
				[ (\(orig=) 2 index str2num (\))] aprintVerbose
				pop

				replace vcid known {
					replace vcid get vgid ne {
						[ (\n\033[1mWARNING: CID ) vcid ( is bound to GID )
						  replace vcid get ( and ) vgid (.\033[m) ] aprintDebug
					} if
					exit
				} if
				replace vcid vgid put
			} repeat
		} forall
		replace {
			exch CIDMap exch GDBytes getstrarray {
				num2str pop
			} {
				/ttfproc-CIDMap-replace trap
			} ifelse
		} forall
	} repeat
	(\n) aprintVerbose
	(done.\n) aprintDebug

	% Metrics2
	%	CID -> [ wx1 wy1 vx vy ]
	% Enumerate Horizontal and Vertical Reverse CMaps.
	% Lookup modified CIDMap to get glyph ID.
	% Lookup wy1 for vmtx table, vx for half of hmtx table.
	% vy is the ascent from OS/2 table.
	ttfdict /vmtx ttfCheckSupport {
		ttfReadOS2Table
		ttfReadHmtxTable /hmtx exch def
		ttfReadVmtxTable /vmtx exch def
		/TypoAscender get /vy exch def
		/hw hmtx /AdvanceDistance get def	% horizontal width
		/hwmax hw length 1 sub def
		/vw vmtx /AdvanceDistance get def	% vertical width
		/vwmax vw length 1 sub def
		1 dict begin	% Metrics2
		[ hcmap /CodeMap get /ReverseCMap get
			vcodemap /ReverseCMap get ] { {
			pop
			[ << /W 7 >> 2 index ] aprintMoreVerbose
			CIDMap 1 index GDBytes getstrarray {
				str2num
				[ (: gid=) << /A /left /W 5 >> 3 index ] aprintMoreVerbose
				[	0	% wx1
					[ ( wx1=) 2 index ] aprintMoreVerbose
					vw 3 index dup vwmax ge { pop vwmax } if get neg
					[ ( wy1=) 2 index ] aprintMoreVerbose
					hw 4 index dup hwmax ge { pop hwmax } if get 0.5 mul
					[ ( vx=) 2 index ] aprintMoreVerbose
					vy
					[ ( vy=) 2 index ] aprintMoreVerbose
				] exch pop def
			} {
				pop (: no glyph) aprintMoreVerbose
			} ifelse
			(\n) aprintMoreVerbose
		} forall } forall

		% cid 1 and 231 is half width space.
		% change height to its width in case of vertical writing.
		% vx in the array of Metrics2 element hold half of charwidth.
		[ 1 231 ] {
			currentdict 1 index known {
				load dup 2 get -2 mul 1 exch put
			} {
				pop
			} ifelse
		} forall

		currentdict end	% Metrics2
	} {
		pop
	} ifelse

	ttfdict ttfCloseFontFile

	end	% vertical-subst

	/Metrics2 exch def

	currentdict end
	fontname exch /CIDFont defineresource

	ttfUndefineCIDInitProcSet
	exch setglobal

	end
} bind def

% test code
{
	/encodings [
		<<
			/HCmap /90ms-RKSJ-H
			/VCmap /90ms-RKSJ-V
			/Arrows <81aa81ab81a981a8>
			/Katakana <8175834c8383836283608383815b81498176>
			/Ansi (abc)
			/PuncSpace <816d20816e816d8140816e>
		>>
		<<
			/HCmap /EUC-H
			/VCmap /EUC-V
			/Arrows <a2aca2ada2aba2aa>
			/Katakana <a1d6a5ada5e3a5c3a5c1a5e3a1bca1aaa1d7>
			/Ansi (abc)
			/PuncSpace <a1ce20a1cfa1cea1a1a1cf>
		>>
		<<
			/HCmap /UniJIS-UTF16-H
			/VCmap /UniJIS-UTF16-V
			/Arrows <2191219321902192>
			/Katakana <300c30ad30e330c330c130e330fcff01300d>
			/Ansi <006100620063>
			/PuncSpace <ff3b0020ff3dff3b3000ff3d>
		>>
	] def
	/fonts [ /MS-PGothic /IPAexMincho /DFPKaiSho-Md ] def

	fonts {
		/f exch def
		encodings {
			begin
			(---------------------------------------------------------\n) print
			24 24 scale
			0 33 translate

			f VCmap ttfVerticalFixupCIDFont pop

			/test-V VCmap [ f ] composefont setfont
			1 -1 moveto
			Arrows show
			Katakana show
			Ansi show
			PuncSpace show

			/test-H HCmap [ f ] composefont setfont
			-0.5 -1.5 rmoveto
			Arrows show
			Katakana show
			Ansi show
			PuncSpace show

			showpage
			end
		} forall
	} forall
	/end dstack
	[ (dictstack depth: ) countdictstack (\n) ] aprint
} pop
